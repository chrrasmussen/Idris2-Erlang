-module('Idris.Idris2.Parser.Rule.Source').
-compile('no_auto_import').
-compile('inline').
-compile({'inline_size',24}).
-export([
  'case--blockWithOptHeaderAfter-4131'/7,
  'case--blockAfter-3953'/5,
  'case--terminator,afterDedent-3592'/5,
  'case--terminator,afterDedent-3557'/5,
  'case--terminator,afterDedent-3526'/4,
  'case--atEndIndent-3488'/3,
  'case--atEnd-3449'/3,
  'case--checkValid-3329'/3,
  'case--checkValid-3303'/3,
  'case--continueF-3206'/4,
  'case--name,nameNS-3043'/3,
  'case--holeName-2949'/2,
  'case--moduleIdent-2920'/2,
  'case--namespacedIdent-2871'/2,
  'case--identPart-2850'/2,
  'case--case block in operator-2821'/3,
  'case--operator-2812'/2,
  'case--case block in pragma-2777'/4,
  'case--pragma-2765'/3,
  'case--case block in exactIdent-2728'/4,
  'case--exactIdent-2716'/3,
  'case--case block in keyword-2679'/4,
  'case--keyword-2667'/3,
  'case--case block in symbol-2627'/4,
  'case--symbol-2615'/3,
  'case--aDotIdent-2582'/2,
  'case--strLit-2561'/2,
  'case--onOffLit-2529'/2,
  'case--intLit-2508'/2,
  'case--documentation\x{27}-2478'/2,
  'case--case block in constant-2374'/3,
  'case--case block in constant-2341'/3,
  'case--constant-2334'/2,
  'nested--5577-3992--in--un--restOfBlock'/6,
  'nested--4634-3031--in--un--reserved'/1,
  'nested--4634-3033--in--un--opNonNS'/0,
  'nested--4634-3034--in--un--opNS'/1,
  'nested--4634-3032--in--un--nameNS'/2,
  'nested--3867-2298--in--un--isEOI'/1,
  'nested--5124-3509--in--un--afterSemi'/3,
  'nested--5124-3510--in--un--afterDedent'/4,
  'un--unqualifiedName'/0,
  'un--terminator'/2,
  'un--symbol'/1,
  'un--strLit'/0,
  'un--reservedNames'/0,
  'un--pragma'/1,
  'un--operator'/0,
  'un--onOffLit'/0,
  'un--nonEmptyBlock'/2,
  'un--namespacedIdent'/0,
  'un--namespaceId'/0,
  'un--name'/0,
  'un--mustContinue'/2,
  'un--moduleIdent'/0,
  'un--keyword'/1,
  'un--isTerminator'/1,
  'un--intLit'/0,
  'un--init'/0,
  'un--identPart'/0,
  'un--holeName'/0,
  'un--exactIdent'/1,
  'un--eoi'/0,
  'un--dotIdent'/0,
  'un--documentation\x{27}'/0,
  'un--documentation'/0,
  'un--continueF'/2,
  'un--continue'/1,
  'un--constant'/0,
  'un--checkValid'/2,
  'un--blockWithOptHeaderAfter'/5,
  'un--blockEntry'/3,
  'un--blockEntries'/3,
  'un--blockAfter'/3,
  'un--block'/2,
  'un--atEndIndent'/1,
  'un--atEnd'/1,
  'un--aDotIdent'/0,
  'un--SourceEmptyRule'/1,
  'un--Rule'/1,
  'un--IndentInfo'/0
]).
'case--blockWithOptHeaderAfter-4131'(V0, V1, V2, V3, V4, V5, V6) -> case V6 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, []}}; 1 -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Text.Parser':'un--optional'('erased', 'erased', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AtPos', V5}, V3)))), fun (V7) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V5}, V2)), fun (V8) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor__Maybe'('erased', 'erased', fun (V9) -> ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V9)) end, V7)), V8}} end} end}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--blockAfter-3953'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Text.Parser.Core.Empty', []}; 1 -> ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V3}, V1)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-3592'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AtPos', V2}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-3557'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AtPos', V2}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-3526'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AnyIndent'}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--atEndIndent-3488'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--atEnd-3449'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--checkValid-3329'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Invalid indentation"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--checkValid-3303'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Text.Parser.Core.Fail', 1, <<"Invalid indentation"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--continueF-3206'(V0, V1, V2, V3) -> case V3 of 0 -> V1; 1 -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--name,nameNS-3043'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Text.Parser.Core.Fail', 1, ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"can\x{27}t use reserved name "/utf8>>, V0))}; 1 -> {'Idris.Text.Parser.Core.Empty', ('Idris.Idris2.Core.Name':'un--mkNamespacedName'(V1, V0))}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--holeName-2949'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.HoleIdent', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--moduleIdent-2920'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.DotSepIdent', E0, E1} -> (fun (V2, V3) -> {'Idris.Prelude.Types.Just', ('Idris.Idris2.Core.Name.Namespace':'un--mkModuleIdent'({'Idris.Prelude.Types.Just', V2}, V3))} end(E0, E1)); {'Idris.Parser.Lexer.Source.Ident', E2} -> (fun (V4) -> {'Idris.Prelude.Types.Just', ('Idris.Idris2.Core.Name.Namespace':'un--mkModuleIdent'({'Idris.Prelude.Types.Nothing'}, V4))} end(E2)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--namespacedIdent-2871'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.DotSepIdent', E0, E1} -> (fun (V2, V3) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Just', V2}, V3}} end(E0, E1)); {'Idris.Parser.Lexer.Source.Ident', E2} -> (fun (V4) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, V4}} end(E2)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--identPart-2850'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in operator-2821'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Prelude.Types.Nothing'}; 1 -> {'Idris.Prelude.Types.Just', {'Idris.Core.Name.UN', V1}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--operator-2812'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V2) -> ('case--case block in operator-2821'(V0, V2, ('Idris.Idris2.Prelude.Types':'un--elem'('erased', {'Idris.Prelude.EqOrd.dn--un--__mkEq', fun (V3) -> fun (V4) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V3, V4)) end end, fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq__String'(V5, V6)) end end}, V2, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))))) end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in pragma-2777'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--pragma-2765'(V0, V1, V2) -> case V2 of {'Idris.Parser.Lexer.Source.Pragma', E0} -> (fun (V3) -> ('case--case block in pragma-2777'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V3, V0)))) end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in exactIdent-2728'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--exactIdent-2716'(V0, V1, V2) -> case V2 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V3) -> ('case--case block in exactIdent-2728'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V3, V0)))) end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in keyword-2679'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--keyword-2667'(V0, V1, V2) -> case V2 of {'Idris.Parser.Lexer.Source.Keyword', E0} -> (fun (V3) -> ('case--case block in keyword-2679'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V3, V0)))) end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in symbol-2627'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--symbol-2615'(V0, V1, V2) -> case V2 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V3) -> ('case--case block in symbol-2627'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V3, V0)))) end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--aDotIdent-2582'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.DotIdent', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--strLit-2561'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.StringLit', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--onOffLit-2529'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V2) -> case V2 of <<"on"/utf8>> -> {'Idris.Prelude.Types.Just', 0}; <<"off"/utf8>> -> {'Idris.Prelude.Types.Just', 1}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--intLit-2508'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.IntegerLit', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--documentation\x{27}-2478'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.DocComment', E0} -> (fun (V2) -> {'Idris.Prelude.Types.Just', V2} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in constant-2374'(V0, V1, V2) -> case V2 of {'Idris.Prelude.Types.Nothing'} -> (fun () -> {'Idris.Prelude.Types.Nothing'} end()); {'Idris.Prelude.Types.Just', E0} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Str', V3}} end(E0)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--case block in constant-2341'(V0, V1, V2) -> case V2 of {'Idris.Prelude.Types.Nothing'} -> (fun () -> {'Idris.Prelude.Types.Nothing'} end()); {'Idris.Prelude.Types.Just', E0} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Ch', V3}} end(E0)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--constant-2334'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.CharLit', E0} -> (fun (V2) -> ('case--case block in constant-2341'(V0, V2, ('Idris.Idris2.Parser.Support':'un--getCharLit'(V2)))) end(E0)); {'Idris.Parser.Lexer.Source.DoubleLit', E1} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Db', V3}} end(E1)); {'Idris.Parser.Lexer.Source.IntegerLit', E2} -> (fun (V4) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.BI', V4}} end(E2)); {'Idris.Parser.Lexer.Source.StringLit', E3} -> (fun (V5) -> ('case--case block in constant-2374'(V0, V5, ('Idris.Idris2.Parser.Support':'un--escape'(V5)))) end(E3)); {'Idris.Parser.Lexer.Source.Ident', E4} -> (fun (V6) -> case V6 of <<"Char"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.CharType'}}; <<"Double"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.DoubleType'}}; <<"Int"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntType'}}; <<"Integer"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntegerType'}}; <<"Bits8"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits8Type'}}; <<"Bits16"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits16Type'}}; <<"Bits32"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits32Type'}}; <<"Bits64"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits64Type'}}; <<"String"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.StringType'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E4)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'nested--5577-3992--in--un--restOfBlock'(V0, V1, V2, V3, V4, V5) -> case V5 of {'Idris.Prelude.Types.Just', E0} -> (fun (V6) -> case V6 of {'Idris.Builtin.MkPair', E1, E2} -> (fun (V7, V8) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', V8, V2)), fun (V9) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> fun (V10) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Just', V7}, V9}} end end} end} end(E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end end(E0)); {'Idris.Prelude.Types.Nothing'} -> (fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V2)), fun (V11) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> fun (V12) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, V11}} end end} end} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'nested--4634-3031--in--un--reserved'(V0) -> ('Idris.Idris2.Prelude.Types':'un--elem'('erased', {'Idris.Prelude.EqOrd.dn--un--__mkEq', fun (V1) -> fun (V2) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__String'(V1, V2)) end end, fun (V3) -> fun (V4) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq__String'(V3, V4)) end end}, V0, ('un--reservedNames'()))).
'nested--4634-3033--in--un--opNonNS'() -> {'Idris.Text.Parser.Core.SeqEmpty', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 0, ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), fun (V0) -> fun (V1) -> V0 end end, {'Idris.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, fun (V2) -> fun (V3) -> V3 end end, ('un--symbol'(<<"("/utf8>>)))), fun (V4) -> ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V4, ('un--operator'()))) end})), fun (V5) -> ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V5, ('un--symbol'(<<")"/utf8>>)))) end}.
'nested--4634-3034--in--un--opNS'(V0) -> {'Idris.Text.Parser.Core.SeqEat', 0, ('un--symbol'(<<".("/utf8>>)), fun () -> fun (V1) -> {'Idris.Text.Parser.Core.SeqEat', 0, ('un--operator'()), fun () -> fun (V2) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<")"/utf8>>)), fun () -> fun (V3) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Core.Name.NS', V0, V2}} end end} end end} end end}.
'nested--4634-3032--in--un--nameNS'(V0, V1) -> ('case--name,nameNS-3043'(V1, V0, ('nested--4634-3031--in--un--reserved'(V1)))).
'nested--3867-2298--in--un--isEOI'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.EndInput'} -> (fun () -> 0 end()); _ -> 1 end.
'nested--5124-3509--in--un--afterSemi'(V0, V1, V2) -> case V2 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> {'Idris.Parser.Rule.Source.AnyIndent'} end()); {'Idris.Parser.Rule.Source.AtPos', E0} -> (fun (V3) -> {'Idris.Parser.Rule.Source.AfterPos', V3} end(E0)); {'Idris.Parser.Rule.Source.AfterPos', E1} -> (fun (V4) -> {'Idris.Parser.Rule.Source.AfterPos', V4} end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Parser.Rule.Source.EndOfBlock'} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'nested--5124-3510--in--un--afterDedent'(V0, V1, V2, V3) -> case V2 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> ('case--terminator,afterDedent-3526'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V3, V0)))) end()); {'Idris.Parser.Rule.Source.AfterPos', E0} -> (fun (V4) -> ('case--terminator,afterDedent-3557'(V0, V1, V4, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V3, V0)))) end(E0)); {'Idris.Parser.Rule.Source.AtPos', E1} -> (fun (V5) -> ('case--terminator,afterDedent-3592'(V0, V1, V5, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V3, V0)))) end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--unqualifiedName'() -> ('un--identPart'()).
'un--terminator'(V0, V1) -> {'Idris.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), fun () -> ('Idris.Idris2.Prelude.Basics':'un--&&'(1, fun () -> 1 end)) end)), {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--eoi'()), fun (V2) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}} end}, fun () -> {'Idris.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), ('Idris.Idris2.Prelude.Basics':'un--&&'(1, fun () -> 1 end)), {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<";"/utf8>>)), fun () -> fun (V3) -> {'Idris.Text.Parser.Core.Empty', ('nested--5124-3509--in--un--afterSemi'(V1, V0, V0))} end end}, fun () -> {'Idris.Text.Parser.Core.Alt', 1, 1, {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V4) -> ('nested--5124-3510--in--un--afterDedent'(V1, V0, V0, V4)) end}, fun () -> {'Idris.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}} end} end} end}.
'un--symbol'(V0) -> {'Idris.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.Strings':'un--++'(V0, <<"\x{27}"/utf8>>)))), fun (V1) -> ('case--symbol-2615'(V0, V1, case V1 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V2, V3, V4, V5, V6, V7) -> V2 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--strLit'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected string literal"/utf8>>, fun (V0) -> ('case--strLit-2561'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--reservedNames'() -> [<<"Type"/utf8>> | [<<"Int"/utf8>> | [<<"Integer"/utf8>> | [<<"Bits8"/utf8>> | [<<"Bits16"/utf8>> | [<<"Bits32"/utf8>> | [<<"Bits64"/utf8>> | [<<"String"/utf8>> | [<<"Char"/utf8>> | [<<"Double"/utf8>> | [<<"Lazy"/utf8>> | [<<"Inf"/utf8>> | [<<"Force"/utf8>> | [<<"Delay"/utf8>> | []]]]]]]]]]]]]]].
'un--pragma'(V0) -> {'Idris.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"Expected pragma "/utf8>>, V0)), fun (V1) -> ('case--pragma-2765'(V0, V1, case V1 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V2, V3, V4, V5, V6, V7) -> V2 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--operator'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected operator"/utf8>>, fun (V0) -> ('case--operator-2812'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--onOffLit'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected on or off"/utf8>>, fun (V0) -> ('case--onOffLit-2529'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--nonEmptyBlock'(V0, V1) -> {'Idris.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 0, {'Idris.Text.Parser.Core.SeqEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> fun (V2) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, {'Idris.Text.Parser.Core.Commit'}, fun (V3) -> {'Idris.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V1)), fun () -> fun (V4) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V4)), V1)), fun (V5) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> fun (V6) -> {'Idris.Text.Parser.Core.Empty', [('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V4)) | V5]} end end} end} end end} end} end end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V7) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AtPos', V7}, V1)), fun () -> fun (V8) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V8)), V1)), fun (V9) -> {'Idris.Text.Parser.Core.Empty', [('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V8)) | V9]} end} end end} end} end}.
'un--namespacedIdent'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected namespaced name"/utf8>>, fun (V0) -> ('case--namespacedIdent-2871'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--namespaceId'() -> ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, fun (V0) -> ('Idris.Idris2.Prelude.Basics':'un--uncurry'('erased', 'erased', 'erased', fun (V1) -> fun (V2) -> ('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V1, V2)) end end, V0)) end, ('un--namespacedIdent'()))).
'un--name'() -> {'Idris.Text.Parser.Core.Alt', 0, 0, ('nested--4634-3033--in--un--opNonNS'()), fun () -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--namespacedIdent'()), fun () -> fun (V0) -> begin (V1 = ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V0))), begin (V2 = ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V0))), {'Idris.Text.Parser.Core.Alt', 0, 1, ('nested--4634-3034--in--un--opNS'(('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V1, V2)))), fun () -> ('nested--4634-3032--in--un--nameNS'(V1, V2)) end} end end end end} end}.
'un--mustContinue'(V0, V1) -> case V1 of {'Idris.Prelude.Types.Nothing'} -> (fun () -> ('un--continueF'({'Idris.Text.Parser.Core.Fail', 0, <<"Unexpected end of expression"/utf8>>}, V0)) end()); {'Idris.Prelude.Types.Just', E0} -> (fun (V2) -> ('un--continueF'({'Idris.Text.Parser.Core.Fail', 0, ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.Strings':'un--++'(V2, <<"\x{27}"/utf8>>))))}, V0)) end(E0)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--moduleIdent'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected module identifier"/utf8>>, fun (V0) -> ('case--moduleIdent-2920'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--keyword'(V0) -> {'Idris.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.Strings':'un--++'(V0, <<"\x{27}"/utf8>>)))), fun (V1) -> ('case--keyword-2667'(V0, V1, case V1 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V2, V3, V4, V5, V6, V7) -> V2 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--isTerminator'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V1) -> case V1 of <<","/utf8>> -> 0; <<"]"/utf8>> -> 0; <<";"/utf8>> -> 0; <<"}"/utf8>> -> 0; <<")"/utf8>> -> 0; <<"|"/utf8>> -> 0; <<"**"/utf8>> -> 0; _ -> 1 end end(E0)); {'Idris.Parser.Lexer.Source.Keyword', E1} -> (fun (V2) -> case V2 of <<"in"/utf8>> -> 0; <<"then"/utf8>> -> 0; <<"else"/utf8>> -> 0; <<"where"/utf8>> -> 0; _ -> 1 end end(E1)); {'Idris.Parser.Lexer.Source.EndInput'} -> (fun () -> 0 end()); _ -> 1 end.
'un--intLit'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected integer literal"/utf8>>, fun (V0) -> ('case--intLit-2508'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--init'() -> 0.
'un--identPart'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected name"/utf8>>, fun (V0) -> ('case--identPart-2850'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--holeName'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected hole name"/utf8>>, fun (V0) -> ('case--holeName-2949'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--exactIdent'(V0) -> {'Idris.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.Strings':'un--++'(<<"Expected "/utf8>>, V0)), fun (V1) -> ('case--exactIdent-2716'(V0, V1, case V1 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V2, V3, V4, V5, V6, V7) -> V2 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--eoi'() -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, {'Idris.Text.Parser.Core.NextIs', <<"Expected end of input"/utf8>>, fun (V0) -> ('nested--3867-2298--in--un--isEOI'(case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}, fun (V7) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}} end}.
'un--dotIdent'() -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> {'Idris.Core.Name.UN', V4} end, ('un--aDotIdent'()))).
'un--documentation\x{27}'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected documentation comment"/utf8>>, fun (V0) -> ('case--documentation\x{27}-2478'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--documentation'() -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Text.Parser.Core':'dn--un--map_Functor__((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> ('Idris.Idris2.Data.Strings':'un--unlines'(V4)) end, ('Idris.Idris2.Text.Parser':'un--some'('erased', 'erased', ('un--documentation\x{27}'()))))).
'un--continueF'(V0, V1) -> {'Idris.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(0, fun () -> 1 end)), {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--eoi'()), fun (V2) -> V0 end}, fun () -> {'Idris.Text.Parser.Core.Alt', 0, 1, {'Idris.Text.Parser.Core.SeqEat', 1, ('un--keyword'(<<"where"/utf8>>)), fun () -> fun (V3) -> V0 end end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V4) -> ('case--continueF-3206'(V1, V0, V4, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V4, V1)))) end} end} end}.
'un--continue'(V0) -> ('un--continueF'({'Idris.Text.Parser.Core.Fail', 1, <<"Unexpected end of expression"/utf8>>}, V0)).
'un--constant'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected constant"/utf8>>, fun (V0) -> ('case--constant-2334'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--checkValid'(V0, V1) -> case V0 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}} end()); {'Idris.Parser.Rule.Source.AtPos', E0} -> (fun (V2) -> ('case--checkValid-3303'(V2, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq__Int'(V1, V2)))) end(E0)); {'Idris.Parser.Rule.Source.AfterPos', E1} -> (fun (V3) -> ('case--checkValid-3329'(V3, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un-->=_Ord__Int'(V1, V3)))) end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Text.Parser.Core.Fail', 1, <<"End of block"/utf8>>} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--blockWithOptHeaderAfter'(V0, V1, V2, V3, V4) -> {'Idris.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 1, {'Idris.Text.Parser.Core.SeqEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> fun (V5) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, {'Idris.Text.Parser.Core.Commit'}, fun (V6) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Text.Parser':'un--optional'('erased', 'erased', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V3)))), fun (V7) -> ('nested--5577-3992--in--un--restOfBlock'('erased', 'erased', V4, V3, V2, V7)) end} end} end end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V8) -> ('case--blockWithOptHeaderAfter-4131'('erased', 'erased', V4, V3, V2, V8, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V8, V2)))) end} end}.
'un--blockEntry'(V0, V1, V2) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V3) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--checkValid'(V1, V3)), fun (V4) -> {'Idris.Text.Parser.Core.SeqEat', 1, (V2(V3)), fun () -> fun (V5) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--terminator'(V1, V3)), fun (V6) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', V5, V6}} end} end end} end} end}.
'un--blockEntries'(V0, V1, V2) -> {'Idris.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(0, fun () -> 1 end)), {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--eoi'()), fun (V3) -> {'Idris.Text.Parser.Core.Empty', []} end}, fun () -> {'Idris.Text.Parser.Core.Alt', 0, 1, {'Idris.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'('erased', V1, V2)), fun () -> fun (V4) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V4)), V2)), fun (V5) -> {'Idris.Text.Parser.Core.Empty', [('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V4)) | V5]} end} end end}, fun () -> {'Idris.Text.Parser.Core.Empty', []} end} end}.
'un--blockAfter'(V0, V1, V2) -> {'Idris.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 1, {'Idris.Text.Parser.Core.SeqEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> fun (V3) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, {'Idris.Text.Parser.Core.Commit'}, fun (V4) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V2)), fun (V5) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> fun (V6) -> {'Idris.Text.Parser.Core.Empty', V5} end end} end} end} end end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V7) -> ('case--blockAfter-3953'('erased', V2, V1, V7, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V7, V1)))) end} end}.
'un--block'(V0, V1) -> {'Idris.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 1, {'Idris.Text.Parser.Core.SeqEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> fun (V2) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, {'Idris.Text.Parser.Core.Commit'}, fun (V3) -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V1)), fun (V4) -> {'Idris.Text.Parser.Core.SeqEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> fun (V5) -> {'Idris.Text.Parser.Core.Empty', V4} end end} end} end} end end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V6) -> ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V6}, V1)) end} end}.
'un--atEndIndent'(V0) -> {'Idris.Text.Parser.Core.Alt', 1, 1, ('un--eoi'()), fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V1) -> ('case--atEndIndent-3488'(V0, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V1, V0)))) end} end}.
'un--atEnd'(V0) -> {'Idris.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(1, fun () -> 1 end)), ('un--eoi'()), fun () -> {'Idris.Text.Parser.Core.Alt', 1, 1, {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, {'Idris.Text.Parser.Core.NextIs', <<"Expected end of block"/utf8>>, fun (V1) -> ('un--isTerminator'(case V1 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V2, V3, V4, V5, V6, V7) -> V2 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}, fun (V8) -> {'Idris.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}} end}, fun () -> {'Idris.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V9) -> ('case--atEnd-3449'(V0, V9, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord__Int'(V9, V0)))) end} end} end}.
'un--aDotIdent'() -> {'Idris.Text.Parser.Core.Terminal', <<"Expected dot+identifier"/utf8>>, fun (V0) -> ('case--aDotIdent-2582'(V0, case V0 of {'Idris.Text.Bounded.MkBounded', E0, E1, E2, E3, E4, E5} -> (fun (V1, V2, V3, V4, V5, V6) -> V1 end(E0, E1, E2, E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end)) end}.
'un--SourceEmptyRule'(V0) -> ('Idris.Idris2.Parser.Rule.Common':'un--EmptyRule'({'Idris.Parser.Lexer.Source.Token'}, V0)).
'un--Rule'(V0) -> ('Idris.Idris2.Parser.Rule.Common':'un--Rule'({'Idris.Parser.Lexer.Source.Token'}, V0)).
'un--IndentInfo'() -> {'Idris.Int'}.
