-module('Idris.Idris2.Parser.Rule.Source').
-compile('no_auto_import').
-compile('inline').
-compile({'inline_size',24}).
-export([
  'case--isCapitalisedIdent-7238'/5,
  'nested--11015-8925--in--un--restOfBlock'/4,
  'nested--9852-7750--in--un--opNS'/2,
  'nested--9852-7749--in--un--nameNS'/2,
  'nested--8452-6398--in--un--isEOI'/1,
  'nested--10473-8366--in--un--afterSemi'/3,
  'nested--10473-8367--in--un--afterDedent'/4,
  'dn--un--neutral_Monoid_ParsingState'/0,
  'dn--un--__Impl_Semigroup_ParsingState'/2,
  'dn--un--__Impl_Monoid_ParsingState'/0,
  'dn--un--<+>_Semigroup_ParsingState'/2,
  'un--unqualifiedOperatorName'/0,
  'un--unqualifiedName'/0,
  'un--toState'/1,
  'un--terminator'/2,
  'un--symbol'/1,
  'un--strLitLines'/0,
  'un--strLit'/0,
  'un--strEnd'/0,
  'un--strBegin'/0,
  'un--simpleStr'/0,
  'un--reservedNames'/0,
  'un--pragma'/1,
  'un--postfixProj'/0,
  'un--optDocumentation'/1,
  'un--operatorCandidate'/0,
  'un--operator'/0,
  'un--opNonNS'/0,
  'un--onOffLit'/0,
  'un--nonEmptyBlockAfter'/2,
  'un--nonEmptyBlock'/1,
  'un--namespacedSymbol'/1,
  'un--namespacedIdent'/0,
  'un--namespaceId'/0,
  'un--nameWithCapital'/1,
  'un--name'/0,
  'un--mustContinue'/2,
  'un--multilineBegin'/0,
  'un--moduleIdent'/0,
  'un--keyword'/1,
  'un--isTerminator'/1,
  'un--isNotReservedSymbol'/1,
  'un--isNotReservedName'/1,
  'un--isCapitalisedIdent'/1,
  'un--interpEnd'/0,
  'un--interpBegin'/0,
  'un--intLit'/0,
  'un--init'/0,
  'un--identWithCapital'/2,
  'un--identPart'/0,
  'un--holeName'/0,
  'un--exactIdent'/1,
  'un--eoi'/0,
  'un--documentation\x{27}'/0,
  'un--documentation'/1,
  'un--decorationFromBounded'/3,
  'un--dataTypeName'/0,
  'un--dataConstructorName'/0,
  'un--continueF'/2,
  'un--continue'/1,
  'un--constant'/0,
  'un--checkValid'/2,
  'un--capitalisedName'/0,
  'un--capitalisedIdent'/0,
  'un--builtinType'/0,
  'un--blockWithOptHeaderAfter'/3,
  'un--blockEntry'/2,
  'un--blockEntries'/2,
  'un--blockAfter'/2,
  'un--block'/1,
  'un--atEndIndent'/1,
  'un--atEnd'/1,
  'un--anyReservedSymbol'/0,
  'un--anyReservedIdent'/0,
  'un--anyKeyword'/0,
  'un--actH'/1,
  'un--actD'/1,
  'un--aDotIdent'/0,
  'un--State'/0,
  'un--Rule'/1,
  'un--ParsingState'/0,
  'un--IndentInfo'/0,
  'un--EmptyRule'/1,
  'un--BRule'/2
]).
'case--isCapitalisedIdent-7238'(V0, V1, V2, V3, V4) -> case V1 of <<""/utf8>> -> case V4 of {'Data.String.StrNil'} -> V3; _ -> case V4 of {'Data.String.StrCons', V5, V6} -> case case ('Idris.Idris2.Prelude.Types':'un--isUpper'(V5)) of 1 -> 1; 0 -> ('Idris.Idris2.Prelude.EqOrd':'dn--un-->_Ord_Char'(V5, case begin (V7 = 160), case ((V7 band 9223372036854775808) =/= 0) of 'true' -> (V7 bor -9223372036854775808); _ -> (V7 band 9223372036854775807) end end of E1 when ((erlang:'is_integer'(E1)) andalso (((E1 >= 0) andalso (E1 =< 55295)) orelse ((E1 >= 57344) andalso (E1 =< 1114111)))) -> E1; _ -> 65533 end)) end of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkUnit'}}; 0 -> V3 end end end; _ -> case V4 of {'Data.String.StrCons', V8, V9} -> case case ('Idris.Idris2.Prelude.Types':'un--isUpper'(V8)) of 1 -> 1; 0 -> ('Idris.Idris2.Prelude.EqOrd':'dn--un-->_Ord_Char'(V8, case begin (V10 = 160), case ((V10 band 9223372036854775808) =/= 0) of 'true' -> (V10 bor -9223372036854775808); _ -> (V10 band 9223372036854775807) end end of E0 when ((erlang:'is_integer'(E0)) andalso (((E0 >= 0) andalso (E0 =< 55295)) orelse ((E0 >= 57344) andalso (E0 =< 1114111)))) -> E0; _ -> 65533 end)) end of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkUnit'}}; 0 -> V3 end end end.
'nested--11015-8925--in--un--restOfBlock'(V0, V1, V2, V3) -> case V3 of {'Prelude.Types.Just', V4} -> case V4 of {'Builtin.MkPair', V5, V6} -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'(V6, V0)), fun (V7) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkPair', {'Prelude.Types.Just', V5}, V7}} end} end} end; {'Prelude.Types.Nothing'} -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'({'Parser.Rule.Source.AnyIndent'}, V0)), fun (V8) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkPair', {'Prelude.Types.Nothing'}, V8}} end} end} end.
'nested--9852-7750--in--un--opNS'(V0, V1) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, ('un--isCapitalisedIdent'(((begin (V7 = fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'(V5, V6)) end end end end), fun (V8) -> fun (V9) -> ((((V7('erased'))('erased'))(V8))(V9)) end end end(fun (V2) -> ('Idris.Idris2.Builtin':'un--snd'(V2)) end))(V1)))), begin (V15 = ('Idris.Idris2.Prelude.Basics':'un--uncurry'(fun (V10) -> fun (V11) -> ('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V10, V11)) end end, case V1 of {'Libraries.Text.Bounded.MkBounded', V12, V13, V14} -> V12 end))), {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<".("/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.SeqEat', 1, {'Libraries.Text.Parser.Core.Alt', 1, 1, ('un--operator'()), fun () -> ('un--postfixProj'()) end}, fun () -> fun (V16) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<")"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Core.Name.NS', V15, V16}} end} end end} end} end}.
'nested--9852-7749--in--un--nameNS'(V0, V1) -> begin (V10 = ((begin (V7 = fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'(V5, V6)) end end end end), fun (V8) -> fun (V9) -> ((((V7('erased'))('erased'))(V8))(V9)) end end end(fun (V2) -> ('Idris.Idris2.Builtin':'un--snd'(V2)) end))(V1))), {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--identWithCapital'(V0, V10)), {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--isNotReservedName'(V10)), {'Libraries.Text.Parser.Core.Empty', ('Idris.Idris2.Prelude.Basics':'un--uncurry'(fun (V11) -> fun (V12) -> ('Idris.Idris2.Core.Name':'un--mkNamespacedName'(V11, V12)) end end, ((begin (V23 = fun (V17) -> fun (V18) -> fun (V19) -> fun (V20) -> case V20 of {'Builtin.MkPair', V21, V22} -> {'Builtin.MkPair', V21, (V19(V22))} end end end end end), fun (V24) -> fun (V25) -> ((((V23('erased'))('erased'))(V24))(V25)) end end end(fun (V16) -> {'Core.Name.Basic', V16} end))(case V1 of {'Libraries.Text.Bounded.MkBounded', V13, V14, V15} -> V13 end))))}}} end.
'nested--8452-6398--in--un--isEOI'(V0) -> case V0 of {'Parser.Lexer.Source.EndInput'} -> 1; _ -> 0 end.
'nested--10473-8366--in--un--afterSemi'(V0, V1, V2) -> case V2 of {'Parser.Rule.Source.AnyIndent'} -> {'Parser.Rule.Source.AnyIndent'}; {'Parser.Rule.Source.AtPos', V3} -> {'Parser.Rule.Source.AfterPos', V3}; {'Parser.Rule.Source.AfterPos', V4} -> {'Parser.Rule.Source.AfterPos', V4}; {'Parser.Rule.Source.EndOfBlock'} -> {'Parser.Rule.Source.EndOfBlock'} end.
'nested--10473-8367--in--un--afterDedent'(V0, V1, V2, V3) -> case V2 of {'Parser.Rule.Source.AnyIndent'} -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)) of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.AnyIndent'}}; 0 -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Not the end of a block entry"/utf8>>} end; {'Parser.Rule.Source.AfterPos', V4} -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)) of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.AtPos', V4}}; 0 -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Not the end of a block entry"/utf8>>} end; {'Parser.Rule.Source.AtPos', V5} -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)) of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.AtPos', V5}}; 0 -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Not the end of a block entry"/utf8>>} end; {'Parser.Rule.Source.EndOfBlock'} -> {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.EndOfBlock'}} end.
'dn--un--neutral_Monoid_ParsingState'() -> {'Parser.Rule.Source.MkState', {'Prelude.Basics.Lin'}, []}.
'dn--un--__Impl_Semigroup_ParsingState'(V0, V1) -> ('dn--un--<+>_Semigroup_ParsingState'(V0, V1)).
'dn--un--__Impl_Monoid_ParsingState'() -> {'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> ('dn--un--<+>_Semigroup_ParsingState'(V0, V1)) end end, ('dn--un--neutral_Monoid_ParsingState'())}.
'dn--un--<+>_Semigroup_ParsingState'(V0, V1) -> case V0 of {'Parser.Rule.Source.MkState', V2, V3} -> case V1 of {'Parser.Rule.Source.MkState', V4, V5} -> {'Parser.Rule.Source.MkState', ('Idris.Idris2.Prelude.Types.SnocList':'un--tailRecAppend'(V2, V4)), ('Idris.Idris2.Prelude.Types.List':'un--tailRecAppend'(V3, V5))} end end.
'un--unqualifiedOperatorName'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected operator"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Symbol', V1} -> ((begin (V51 = fun (V47) -> fun (V48) -> fun (V49) -> fun (V50) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V49, V50)) end end end end), fun (V52) -> fun (V53) -> ((((V51('erased'))('erased'))(V52))(V53)) end end end(fun (V46) -> V1 end))(('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V4, V5)) end end end end, fun (V6) -> fun (V7) -> {'Prelude.Types.Just', V7} end end, fun (V8) -> fun (V9) -> fun (V10) -> fun (V11) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V10, V11)) end end end end}, fun (V12) -> {'Prelude.Types.Nothing'} end, fun (V13) -> fun (V14) -> fun (V15) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V14, V15)) end end end}, case ('Idris.Idris2.Prelude.Types':'un--elem'({'Prelude.Interfaces.MkFoldable', fun (V16) -> fun (V17) -> fun (V18) -> fun (V19) -> fun (V20) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldr_Foldable_List'(V18, V19, V20)) end end end end end, fun (V21) -> fun (V22) -> fun (V23) -> fun (V24) -> fun (V25) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldl_Foldable_List'(V23, V24, V25)) end end end end end, fun (V26) -> fun (V27) -> ('Idris.Idris2.Prelude.Types':'dn--un--null_Foldable_List'(V27)) end end, fun (V28) -> fun (V29) -> fun (V30) -> fun (V31) -> fun (V32) -> fun (V33) -> fun (V34) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldlM_Foldable_List'(V31, V32, V33, V34)) end end end end end end end, fun (V35) -> fun (V36) -> V36 end end, fun (V37) -> fun (V38) -> fun (V39) -> fun (V40) -> fun (V41) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'(V39, V40, V41)) end end end end end}, {'Prelude.EqOrd.MkEq', fun (V42) -> fun (V43) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V42, V43)) end end, fun (V44) -> fun (V45) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V44, V45)) end end}, V1, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))) of 1 -> 0; 0 -> 1 end)))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--unqualifiedName'() -> ('un--identPart'()).
'un--toState'(V0) -> case V0 of {'Parser.Rule.Source.MkState', V1, V2} -> {'Parser.Rule.Source.MkState', ('Idris.Idris2.Data.SnocList':'dn--un--cast_Cast_(SnocList $a)_(List $a)'(V1)), V2} end.
'un--terminator'(V0, V1) -> {'Libraries.Text.Parser.Core.Alt', 0, 0, {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--eoi'()), {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.EndOfBlock'}}}, fun () -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<";"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', ('nested--10473-8366--in--un--afterSemi'(V1, V0, V0))} end}, fun () -> {'Libraries.Text.Parser.Core.Alt', 0, 0, {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V2) -> ('nested--10473-8367--in--un--afterDedent'(V1, V0, V0, V2)) end}, fun () -> {'Libraries.Text.Parser.Core.Empty', {'Parser.Rule.Source.EndOfBlock'}} end} end} end}.
'un--symbol'(V0) -> {'Libraries.Text.Parser.Core.Terminal', <<<<"Expected \x{27}"/utf8>>/binary, <<V0/binary, <<"\x{27}"/utf8>>/binary>>/binary>>, fun (V1) -> case V1 of {'Parser.Lexer.Source.Symbol', V2} -> ('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end, fun (V7) -> fun (V8) -> {'Prelude.Types.Just', V8} end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V11, V12)) end end end end}, fun (V13) -> {'Prelude.Types.Nothing'} end, fun (V14) -> fun (V15) -> fun (V16) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V15, V16)) end end end}, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--strLitLines'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string literal"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.StringLit', V1, V2} -> ('Idris.Idris2.Data.List1':'dn--un--traverse_Traversable_List1'({'Prelude.Interfaces.MkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end, fun (V7) -> fun (V8) -> {'Prelude.Types.Just', V8} end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V11, V12)) end end end end}, fun (V13) -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, ('Idris.Idris2.Prelude.Types':'un--fastPack'(V13)))) end, ('Idris.Idris2.Libraries.Data.List.Extra':'un--splitAfter'(fun (V14) -> ('Idris.Idris2.Prelude.Types':'un--isNL'(V14)) end, ('Idris.Idris2.Prelude.Types':'un--fastUnpack'(V2)))))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--strLit'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string literal"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.StringLit', V1, V2} -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, V2)); _ -> {'Prelude.Types.Nothing'} end end}.
'un--strEnd'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string end"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.StringEnd'} -> {'Prelude.Types.Just', {'Builtin.MkUnit'}}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--strBegin'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string begin"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.StringBegin', V1} -> case V1 of 1 -> {'Prelude.Types.Just', {'Builtin.MkUnit'}}; _ -> {'Prelude.Types.Nothing'} end; _ -> {'Prelude.Types.Nothing'} end end}.
'un--simpleStr'() -> {'Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ((begin (V40 = fun (V36) -> fun (V37) -> fun (V38) -> fun (V39) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V38, V39)) end end end end), fun (V41) -> fun (V42) -> ((((V40('erased'))('erased'))(V41))(V42)) end end end(fun (V34) -> fun (V35) -> V34 end end))({'Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ((begin (V23 = fun (V19) -> fun (V20) -> fun (V21) -> fun (V22) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V21, V22)) end end end end), fun (V24) -> fun (V25) -> ((((V23('erased'))('erased'))(V24))(V25)) end end end(fun (V17) -> fun (V18) -> V18 end end))({'Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ((begin (V6 = fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V4, V5)) end end end end), fun (V7) -> fun (V8) -> ((((V6('erased'))('erased'))(V7))(V8)) end end end(fun (V0) -> fun (V1) -> V1 end end))(('un--strBegin'()))), fun (V9) -> ((begin (V14 = fun (V10) -> fun (V11) -> fun (V12) -> fun (V13) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(0, V12, V13)) end end end end), fun (V15) -> fun (V16) -> ((((V14('erased'))('erased'))(V15))(V16)) end end end(V9))({'Libraries.Text.Parser.Core.Commit'})) end})), fun (V26) -> ((begin (V31 = fun (V27) -> fun (V28) -> fun (V29) -> fun (V30) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(0, V29, V30)) end end end end), fun (V32) -> fun (V33) -> ((((V31('erased'))('erased'))(V32))(V33)) end end end(V26))(('Idris.Idris2.Libraries.Text.Parser':'un--option'(1, <<""/utf8>>, ('un--strLit'()))))) end})), fun (V43) -> ((begin (V48 = fun (V44) -> fun (V45) -> fun (V46) -> fun (V47) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V46, V47)) end end end end), fun (V49) -> fun (V50) -> ((((V48('erased'))('erased'))(V49))(V50)) end end end(V43))(('un--strEnd'()))) end}.
'un--reservedNames'() -> [<<"Type"/utf8>> | [<<"Int"/utf8>> | [<<"Int8"/utf8>> | [<<"Int16"/utf8>> | [<<"Int32"/utf8>> | [<<"Int64"/utf8>> | [<<"Integer"/utf8>> | [<<"Bits8"/utf8>> | [<<"Bits16"/utf8>> | [<<"Bits32"/utf8>> | [<<"Bits64"/utf8>> | [<<"String"/utf8>> | [<<"Char"/utf8>> | [<<"Double"/utf8>> | [<<"Lazy"/utf8>> | [<<"Inf"/utf8>> | [<<"Force"/utf8>> | [<<"Delay"/utf8>> | []]]]]]]]]]]]]]]]]]].
'un--pragma'(V0) -> {'Libraries.Text.Parser.Core.Terminal', <<<<"Expected pragma "/utf8>>/binary, V0/binary>>, fun (V1) -> case V1 of {'Parser.Lexer.Source.Pragma', V2} -> ('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end, fun (V7) -> fun (V8) -> {'Prelude.Types.Just', V8} end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V11, V12)) end end end end}, fun (V13) -> {'Prelude.Types.Nothing'} end, fun (V14) -> fun (V15) -> fun (V16) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V15, V16)) end end end}, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--postfixProj'() -> ((begin (V5 = fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V3, V4)) end end end end), fun (V6) -> fun (V7) -> ((((V5('erased'))('erased'))(V6))(V7)) end end end(fun (V0) -> {'Core.Name.UN', {'Core.Name.Field', V0}} end))(('un--aDotIdent'()))).
'un--optDocumentation'(V0) -> ('Idris.Idris2.Libraries.Text.Parser':'un--option'(1, <<""/utf8>>, ('un--documentation'(V0)))).
'un--operatorCandidate'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected operator"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Symbol', V1} -> {'Prelude.Types.Just', {'Core.Name.UN', {'Core.Name.Basic', V1}}}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--operator'() -> ((begin (V5 = fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V3, V4)) end end end end), fun (V6) -> fun (V7) -> ((((V5('erased'))('erased'))(V6))(V7)) end end end(fun (V0) -> {'Core.Name.UN', {'Core.Name.Basic', V0}} end))(('un--unqualifiedOperatorName'()))).
'un--opNonNS'() -> {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"("/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEat', 1, {'Libraries.Text.Parser.Core.Bounds', {'Libraries.Text.Parser.Core.Alt', 1, 1, ('un--operatorCandidate'()), fun () -> ('un--postfixProj'()) end}}, fun () -> fun (V0) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, ('un--isNotReservedSymbol'(((begin (V6 = fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'(V4, V5)) end end end end), fun (V7) -> fun (V8) -> ((((V6('erased'))('erased'))(V7))(V8)) end end end(fun (V1) -> ('Idris.Idris2.Core.Name':'un--nameRoot'(V1)) end))(V0)))), {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<")"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', case V0 of {'Libraries.Text.Bounded.MkBounded', V9, V10, V11} -> V9 end} end}} end end}} end}.
'un--onOffLit'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected on or off"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Ident', V1} -> case V1 of <<"on"/utf8>> -> {'Prelude.Types.Just', 1}; <<"off"/utf8>> -> {'Prelude.Types.Just', 0}; _ -> {'Prelude.Types.Nothing'} end; _ -> {'Prelude.Types.Nothing'} end end}.
'un--nonEmptyBlockAfter'(V0, V1) -> {'Libraries.Text.Parser.Core.Alt', 1, 1, {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'({'Parser.Rule.Source.AnyIndent'}, V1)), fun () -> fun (V2) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'(('Idris.Idris2.Builtin':'un--snd'(V2)), V1)), fun (V3) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'(V2)), V3}} end} end} end end}} end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V4) -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V4, V0)) of 0 -> {'Libraries.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'({'Parser.Rule.Source.AtPos', V4}, V1)), fun () -> fun (V5) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('un--blockEntries'(('Idris.Idris2.Builtin':'un--snd'(V5)), V1)), fun (V6) -> {'Libraries.Text.Parser.Core.Empty', {'Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'(V5)), V6}} end} end end}; 1 -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 1, <<"Expected an indented non-empty block"/utf8>>} end end} end}.
'un--nonEmptyBlock'(V0) -> {'Libraries.Text.Parser.Core.Alt', 1, 1, {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'({'Parser.Rule.Source.AnyIndent'}, V0)), fun () -> fun (V1) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'(('Idris.Idris2.Builtin':'un--snd'(V1)), V0)), fun (V2) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'(V1)), V2}} end} end} end end}} end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V3) -> {'Libraries.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'({'Parser.Rule.Source.AtPos', V3}, V0)), fun () -> fun (V4) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('un--blockEntries'(('Idris.Idris2.Builtin':'un--snd'(V4)), V0)), fun (V5) -> {'Libraries.Text.Parser.Core.Empty', {'Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'(V4)), V5}} end} end end} end} end}.
'un--namespacedSymbol'(V0) -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ((begin (V6 = fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V4, V5)) end end end end), fun (V7) -> fun (V8) -> ((((V6('erased'))('erased'))(V7))(V8)) end end end(fun (V1) -> {'Prelude.Types.Nothing'} end))(('un--symbol'(V0)))), fun () -> {'Libraries.Text.Parser.Core.SeqEat', 1, ('un--namespaceId'()), fun () -> fun (V9) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<<<"."/utf8>>/binary, V0/binary>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', {'Prelude.Types.Just', V9}} end} end end} end}.
'un--namespacedIdent'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected namespaced name"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.DotSepIdent', V1, V2} -> {'Prelude.Types.Just', {'Builtin.MkPair', {'Prelude.Types.Just', V1}, V2}}; {'Parser.Lexer.Source.Ident', V3} -> {'Prelude.Types.Just', {'Builtin.MkPair', {'Prelude.Types.Nothing'}, V3}}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--namespaceId'() -> {'Libraries.Text.Parser.Core.SeqEat', 0, {'Libraries.Text.Parser.Core.Bounds', ('un--namespacedIdent'())}, fun () -> fun (V0) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--isCapitalisedIdent'(((begin (V6 = fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'(V4, V5)) end end end end), fun (V7) -> fun (V8) -> ((((V6('erased'))('erased'))(V7))(V8)) end end end(fun (V1) -> ('Idris.Idris2.Builtin':'un--snd'(V1)) end))(V0)))), {'Libraries.Text.Parser.Core.Empty', ('Idris.Idris2.Prelude.Basics':'un--uncurry'(fun (V9) -> fun (V10) -> ('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V9, V10)) end end, case V0 of {'Libraries.Text.Bounded.MkBounded', V11, V12, V13} -> V11 end))}} end end}.
'un--nameWithCapital'(V0) -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ('un--opNonNS'()), fun () -> {'Libraries.Text.Parser.Core.SeqEat', 0, {'Libraries.Text.Parser.Core.Bounds', ('un--namespacedIdent'())}, fun () -> fun (V1) -> {'Libraries.Text.Parser.Core.Alt', 1, 0, ('nested--9852-7750--in--un--opNS'(V0, V1)), fun () -> ('nested--9852-7749--in--un--nameNS'(V0, V1)) end} end end} end}.
'un--name'() -> ('un--nameWithCapital'(0)).
'un--mustContinue'(V0, V1) -> case V1 of {'Prelude.Types.Nothing'} -> ('un--continueF'({'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 1, <<"Unexpected end of expression"/utf8>>}, V0)); {'Prelude.Types.Just', V2} -> ('un--continueF'({'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 1, <<<<"Expected \x{27}"/utf8>>/binary, <<V2/binary, <<"\x{27}"/utf8>>/binary>>/binary>>}, V0)) end.
'un--multilineBegin'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected multiline string begin"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.StringBegin', V1} -> case V1 of 0 -> {'Prelude.Types.Just', {'Builtin.MkUnit'}}; _ -> {'Prelude.Types.Nothing'} end; _ -> {'Prelude.Types.Nothing'} end end}.
'un--moduleIdent'() -> ((begin (V5 = fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V3, V4)) end end end end), fun (V6) -> fun (V7) -> ((((V5('erased'))('erased'))(V6))(V7)) end end end(fun (V0) -> ('Idris.Idris2.Core.Name.Namespace':'un--nsAsModuleIdent'(V0)) end))(('un--namespaceId'()))).
'un--keyword'(V0) -> {'Libraries.Text.Parser.Core.Terminal', <<<<"Expected \x{27}"/utf8>>/binary, <<V0/binary, <<"\x{27}"/utf8>>/binary>>/binary>>, fun (V1) -> case V1 of {'Parser.Lexer.Source.Keyword', V2} -> ('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end, fun (V7) -> fun (V8) -> {'Prelude.Types.Just', V8} end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V11, V12)) end end end end}, fun (V13) -> {'Prelude.Types.Nothing'} end, fun (V14) -> fun (V15) -> fun (V16) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V15, V16)) end end end}, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--isTerminator'(V0) -> case V0 of {'Parser.Lexer.Source.Symbol', V1} -> case V1 of <<","/utf8>> -> 1; <<"]"/utf8>> -> 1; <<";"/utf8>> -> 1; <<"}"/utf8>> -> 1; <<")"/utf8>> -> 1; <<"|"/utf8>> -> 1; <<"**"/utf8>> -> 1; _ -> 0 end; {'Parser.Lexer.Source.Keyword', V2} -> case V2 of <<"in"/utf8>> -> 1; <<"then"/utf8>> -> 1; <<"else"/utf8>> -> 1; <<"where"/utf8>> -> 1; _ -> 0 end; {'Parser.Lexer.Source.InterpEnd'} -> 1; {'Parser.Lexer.Source.EndInput'} -> 1; _ -> 0 end.
'un--isNotReservedSymbol'(V0) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(('Idris.Idris2.Prelude.Types':'un--elem'({'Prelude.Interfaces.MkFoldable', fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldr_Foldable_List'(V3, V4, V5)) end end end end end, fun (V6) -> fun (V7) -> fun (V8) -> fun (V9) -> fun (V10) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldl_Foldable_List'(V8, V9, V10)) end end end end end, fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--null_Foldable_List'(V12)) end end, fun (V13) -> fun (V14) -> fun (V15) -> fun (V16) -> fun (V17) -> fun (V18) -> fun (V19) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldlM_Foldable_List'(V16, V17, V18, V19)) end end end end end end end, fun (V20) -> fun (V21) -> V21 end end, fun (V22) -> fun (V23) -> fun (V24) -> fun (V25) -> fun (V26) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'(V24, V25, V26)) end end end end end}, {'Prelude.EqOrd.MkEq', fun (V27) -> fun (V28) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V27, V28)) end end, fun (V29) -> fun (V30) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V29, V30)) end end}, case V0 of {'Libraries.Text.Bounded.MkBounded', V31, V32, V33} -> V31 end, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))), fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Just', case V0 of {'Libraries.Text.Bounded.MkBounded', V34, V35, V36} -> V36 end}, 0, ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V37) -> fun (V38) -> <<V37/binary, V38/binary>> end end, <<""/utf8>>}, fun (V39) -> V39 end, [<<"Can\x{27}t use reserved symbol "/utf8>> | [case V0 of {'Libraries.Text.Bounded.MkBounded', V40, V41, V42} -> V40 end | []]]))} end)).
'un--isNotReservedName'(V0) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(('Idris.Idris2.Prelude.Types':'un--elem'({'Prelude.Interfaces.MkFoldable', fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldr_Foldable_List'(V3, V4, V5)) end end end end end, fun (V6) -> fun (V7) -> fun (V8) -> fun (V9) -> fun (V10) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldl_Foldable_List'(V8, V9, V10)) end end end end end, fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--null_Foldable_List'(V12)) end end, fun (V13) -> fun (V14) -> fun (V15) -> fun (V16) -> fun (V17) -> fun (V18) -> fun (V19) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldlM_Foldable_List'(V16, V17, V18, V19)) end end end end end end end, fun (V20) -> fun (V21) -> V21 end end, fun (V22) -> fun (V23) -> fun (V24) -> fun (V25) -> fun (V26) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'(V24, V25, V26)) end end end end end}, {'Prelude.EqOrd.MkEq', fun (V27) -> fun (V28) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V27, V28)) end end, fun (V29) -> fun (V30) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V29, V30)) end end}, case V0 of {'Libraries.Text.Bounded.MkBounded', V31, V32, V33} -> V31 end, ('un--reservedNames'()))), fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Just', case V0 of {'Libraries.Text.Bounded.MkBounded', V34, V35, V36} -> V36 end}, 0, ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V37) -> fun (V38) -> <<V37/binary, V38/binary>> end end, <<""/utf8>>}, fun (V39) -> V39 end, [<<"Can\x{27}t use reserved name "/utf8>> | [case V0 of {'Libraries.Text.Bounded.MkBounded', V40, V41, V42} -> V40 end | []]]))} end)).
'un--isCapitalisedIdent'(V0) -> begin (V4 = case V0 of {'Libraries.Text.Bounded.MkBounded', V1, V2, V3} -> V1 end), begin (V8 = case V0 of {'Libraries.Text.Bounded.MkBounded', V5, V6, V7} -> V7 end), begin (V9 = {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Just', V8}, 0, <<<<"Expected a capitalised identifier, got: "/utf8>>/binary, V4/binary>>}), ('case--isCapitalisedIdent-7238'(V0, V4, V8, V9, ('Idris.Idris2.Data.String':'un--strM'(V4)))) end end end.
'un--interpEnd'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string interp end"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.InterpEnd'} -> {'Prelude.Types.Just', {'Builtin.MkUnit'}}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--interpBegin'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected string interp begin"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.InterpBegin'} -> {'Prelude.Types.Just', {'Builtin.MkUnit'}}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--intLit'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected integer literal"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.IntegerLit', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--init'() -> 0.
'un--identWithCapital'(V0, V1) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(V0, fun () -> ('un--isCapitalisedIdent'(V1)) end)).
'un--identPart'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected name"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Ident', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--holeName'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected hole name"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.HoleIdent', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--exactIdent'(V0) -> {'Libraries.Text.Parser.Core.Terminal', <<<<"Expected "/utf8>>/binary, V0/binary>>, fun (V1) -> case V1 of {'Parser.Lexer.Source.Ident', V2} -> ('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end, fun (V7) -> fun (V8) -> {'Prelude.Types.Just', V8} end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V11, V12)) end end end end}, fun (V13) -> {'Prelude.Types.Nothing'} end, fun (V14) -> fun (V15) -> fun (V16) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V15, V16)) end end end}, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--eoi'() -> ((begin (V6 = fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(0, V4, V5)) end end end end), fun (V7) -> fun (V8) -> ((((V6('erased'))('erased'))(V7))(V8)) end end end(fun (V1) -> {'Builtin.MkUnit'} end))({'Libraries.Text.Parser.Core.NextIs', <<"Expected end of input"/utf8>>, fun (V0) -> ('nested--8452-6398--in--un--isEOI'(V0)) end})).
'un--documentation\x{27}'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected documentation comment"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.DocComment', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--documentation'(V0) -> {'Libraries.Text.Parser.Core.SeqEat', 0, {'Libraries.Text.Parser.Core.Bounds', ('Idris.Idris2.Libraries.Text.Parser':'un--some'(('un--documentation\x{27}'())))}, fun () -> fun (V1) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--actD'(('un--decorationFromBounded'(V0, 0, V1)))), {'Libraries.Text.Parser.Core.Empty', ('Idris.Idris2.Data.String':'un--fastUnlines'(('Idris.Idris2.Data.List1':'un--forget'(case V1 of {'Libraries.Text.Bounded.MkBounded', V2, V3, V4} -> V2 end))))}} end end}.
'un--decorationFromBounded'(V0, V1, V2) -> {'Builtin.MkPair', {'Builtin.MkPair', V0, {'Builtin.MkPair', ('Idris.Idris2.Libraries.Text.Bounded':'un--start'(V2)), ('Idris.Idris2.Libraries.Text.Bounded':'un--end'(V2))}}, {'Builtin.MkPair', V1, {'Prelude.Types.Nothing'}}}.
'un--dataTypeName'() -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ('un--opNonNS'()), fun () -> ('un--capitalisedName'()) end}.
'un--dataConstructorName'() -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ('un--opNonNS'()), fun () -> ((begin (V5 = fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V3, V4)) end end end end), fun (V6) -> fun (V7) -> ((((V5('erased'))('erased'))(V6))(V7)) end end end(fun (V0) -> {'Core.Name.UN', {'Core.Name.Basic', V0}} end))(('un--capitalisedIdent'()))) end}.
'un--continueF'(V0, V1) -> {'Libraries.Text.Parser.Core.Alt', 0, 0, {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--eoi'()), V0}, fun () -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--keyword'(<<"where"/utf8>>)), fun () -> V0 end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V2) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V2, V1)), fun () -> V0 end)) end} end} end}.
'un--continue'(V0) -> ('un--continueF'({'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Unexpected end of expression"/utf8>>}, V0)).
'un--constant'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected constant"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.CharLit', V1} -> ((begin (V7 = fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V5, V6)) end end end end), fun (V8) -> fun (V9) -> ((((V7('erased'))('erased'))(V8))(V9)) end end end(fun (V2) -> {'Core.TT.Ch', V2} end))(('Idris.Idris2.Parser.Support':'un--getCharLit'(V1)))); {'Parser.Lexer.Source.DoubleLit', V10} -> {'Prelude.Types.Just', {'Core.TT.Db', V10}}; {'Parser.Lexer.Source.IntegerLit', V11} -> {'Prelude.Types.Just', {'Core.TT.BI', V11}}; {'Parser.Lexer.Source.Ident', V12} -> ('Idris.Idris2.Prelude.Types':'dn--un-->>=_Monad_Maybe'(('Idris.Idris2.Core.TT':'un--isConstantType'({'Core.Name.UN', {'Core.Name.Basic', V12}})), fun (V13) -> case V13 of 13 -> {'Prelude.Types.Nothing'}; _ -> {'Prelude.Types.Just', {'Core.TT.PrT', V13}} end end)); _ -> {'Prelude.Types.Nothing'} end end}.
'un--checkValid'(V0, V1) -> case V0 of {'Parser.Rule.Source.AnyIndent'} -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkUnit'}}; {'Parser.Rule.Source.AtPos', V2} -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(case ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_Int'(V1, V2)) of 1 -> 0; 0 -> 1 end, fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Invalid indentation"/utf8>>} end)); {'Parser.Rule.Source.AfterPos', V3} -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(case ('Idris.Idris2.Prelude.EqOrd':'dn--un-->=_Ord_Int'(V1, V3)) of 1 -> 0; 0 -> 1 end, fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Invalid indentation"/utf8>>} end)); {'Parser.Rule.Source.EndOfBlock'} -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"End of block"/utf8>>} end.
'un--capitalisedName'() -> ('un--nameWithCapital'(1)).
'un--capitalisedIdent'() -> {'Libraries.Text.Parser.Core.SeqEat', 0, {'Libraries.Text.Parser.Core.Bounds', ('un--identPart'())}, fun () -> fun (V0) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--isCapitalisedIdent'(V0)), {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--isNotReservedName'(V0)), {'Libraries.Text.Parser.Core.Empty', case V0 of {'Libraries.Text.Bounded.MkBounded', V1, V2, V3} -> V1 end}}} end end}.
'un--builtinType'() -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ((begin (V5 = fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V3, V4)) end end end end), fun (V6) -> fun (V7) -> ((((V5('erased'))('erased'))(V6))(V7)) end end end(fun (V0) -> 0 end))(('un--exactIdent'(<<"Natural"/utf8>>)))), fun () -> {'Libraries.Text.Parser.Core.Alt', 1, 1, ((begin (V13 = fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V11, V12)) end end end end), fun (V14) -> fun (V15) -> ((((V13('erased'))('erased'))(V14))(V15)) end end end(fun (V8) -> 1 end))(('un--exactIdent'(<<"NaturalToInteger"/utf8>>)))), fun () -> ((begin (V21 = fun (V17) -> fun (V18) -> fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(1, V19, V20)) end end end end), fun (V22) -> fun (V23) -> ((((V21('erased'))('erased'))(V22))(V23)) end end end(fun (V16) -> 2 end))(('un--exactIdent'(<<"IntegerToNatural"/utf8>>)))) end} end}.
'un--blockWithOptHeaderAfter'(V0, V1, V2) -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser':'un--optional'(1, ('un--blockEntry'({'Parser.Rule.Source.AnyIndent'}, V1)))), fun (V3) -> ('nested--11015-8925--in--un--restOfBlock'(V2, V1, V0, V3)) end}} end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V4) -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V4, V0)) of 1 -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkPair', {'Prelude.Types.Nothing'}, []}}; 0 -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--optional'(1, ('un--blockEntry'({'Parser.Rule.Source.AtPos', V4}, V1)))), fun (V5) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('un--blockEntries'({'Parser.Rule.Source.AtPos', V4}, V2)), fun (V6) -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkPair', ((begin (V12 = fun (V8) -> fun (V9) -> fun (V10) -> fun (V11) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V10, V11)) end end end end), fun (V13) -> fun (V14) -> ((((V12('erased'))('erased'))(V13))(V14)) end end end(fun (V7) -> ('Idris.Idris2.Builtin':'un--fst'(V7)) end))(V5)), V6}} end} end} end end} end}.
'un--blockEntry'(V0, V1) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V2) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, ('un--checkValid'(V0, V2)), {'Libraries.Text.Parser.Core.SeqEat', 0, (V1(V2)), fun () -> fun (V3) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('un--terminator'(V0, V2)), fun (V4) -> {'Libraries.Text.Parser.Core.Empty', {'Builtin.MkPair', V3, V4}} end} end end}} end}.
'un--blockEntries'(V0, V1) -> {'Libraries.Text.Parser.Core.Alt', 0, 0, {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('un--eoi'()), {'Libraries.Text.Parser.Core.Empty', []}}, fun () -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'(V0, V1)), fun () -> fun (V2) -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('un--blockEntries'(('Idris.Idris2.Builtin':'un--snd'(V2)), V1)), fun (V3) -> {'Libraries.Text.Parser.Core.Empty', [('Idris.Idris2.Builtin':'un--fst'(V2)) | V3]} end} end end}, fun () -> {'Libraries.Text.Parser.Core.Empty', []} end} end}.
'un--blockAfter'(V0, V1) -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'({'Parser.Rule.Source.AnyIndent'}, V1)), fun (V2) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', V2} end} end}} end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V3) -> case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)) of 1 -> {'Libraries.Text.Parser.Core.Empty', []}; 0 -> ('un--blockEntries'({'Parser.Rule.Source.AtPos', V3}, V1)) end end} end}.
'un--block'(V0) -> {'Libraries.Text.Parser.Core.Alt', 1, 0, {'Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 1, {'Libraries.Text.Parser.Core.Commit'}, {'Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('un--blockEntries'({'Parser.Rule.Source.AnyIndent'}, V0)), fun (V1) -> {'Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Libraries.Text.Parser.Core.Empty', V1} end} end}} end}, fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V2) -> ('un--blockEntries'({'Parser.Rule.Source.AtPos', V2}, V0)) end} end}.
'un--atEndIndent'(V0) -> {'Libraries.Text.Parser.Core.Alt', 0, 0, ('un--eoi'()), fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V1) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V1, V0)) of 1 -> 0; 0 -> 1 end, fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Not the end of a block entry"/utf8>>} end)) end} end}.
'un--atEnd'(V0) -> {'Libraries.Text.Parser.Core.Alt', 0, 0, ('un--eoi'()), fun () -> {'Libraries.Text.Parser.Core.Alt', 0, 0, ((begin (V7 = fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_(((Grammar $state) $tok) $c)'(0, V5, V6)) end end end end), fun (V8) -> fun (V9) -> ((((V7('erased'))('erased'))(V8))(V9)) end end end(fun (V2) -> {'Builtin.MkUnit'} end))({'Libraries.Text.Parser.Core.NextIs', <<"Expected end of block"/utf8>>, fun (V1) -> ('un--isTerminator'(V1)) end})), fun () -> {'Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--column'()), fun (V10) -> ('Idris.Idris2.Libraries.Text.Parser':'un--when'(case ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V10, V0)) of 1 -> 0; 0 -> 1 end, fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Nothing'}, 0, <<"Not the end of a block entry"/utf8>>} end)) end} end} end}.
'un--anyReservedSymbol'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected a reserved symbol"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Symbol', V1} -> ((begin (V51 = fun (V47) -> fun (V48) -> fun (V49) -> fun (V50) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V49, V50)) end end end end), fun (V52) -> fun (V53) -> ((((V51('erased'))('erased'))(V52))(V53)) end end end(fun (V46) -> V1 end))(('Idris.Idris2.Prelude.Interfaces':'un--guard'({'Prelude.Interfaces.MkAlternative', {'Prelude.Interfaces.MkApplicative', fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'(V4, V5)) end end end end, fun (V6) -> fun (V7) -> {'Prelude.Types.Just', V7} end end, fun (V8) -> fun (V9) -> fun (V10) -> fun (V11) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'(V10, V11)) end end end end}, fun (V12) -> {'Prelude.Types.Nothing'} end, fun (V13) -> fun (V14) -> fun (V15) -> ('Idris.Idris2.Prelude.Types':'dn--un--<|>_Alternative_Maybe'(V14, V15)) end end end}, ('Idris.Idris2.Prelude.Types':'un--elem'({'Prelude.Interfaces.MkFoldable', fun (V16) -> fun (V17) -> fun (V18) -> fun (V19) -> fun (V20) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldr_Foldable_List'(V18, V19, V20)) end end end end end, fun (V21) -> fun (V22) -> fun (V23) -> fun (V24) -> fun (V25) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldl_Foldable_List'(V23, V24, V25)) end end end end end, fun (V26) -> fun (V27) -> ('Idris.Idris2.Prelude.Types':'dn--un--null_Foldable_List'(V27)) end end, fun (V28) -> fun (V29) -> fun (V30) -> fun (V31) -> fun (V32) -> fun (V33) -> fun (V34) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldlM_Foldable_List'(V31, V32, V33, V34)) end end end end end end end, fun (V35) -> fun (V36) -> V36 end end, fun (V37) -> fun (V38) -> fun (V39) -> fun (V40) -> fun (V41) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'(V39, V40, V41)) end end end end end}, {'Prelude.EqOrd.MkEq', fun (V42) -> fun (V43) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V42, V43)) end end, fun (V44) -> fun (V45) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V44, V45)) end end}, V1, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))))))); _ -> {'Prelude.Types.Nothing'} end end}.
'un--anyReservedIdent'() -> {'Libraries.Text.Parser.Core.SeqEat', 0, {'Libraries.Text.Parser.Core.Bounds', ('un--identPart'())}, fun () -> fun (V0) -> {'Libraries.Text.Parser.Core.ThenEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--when'(case ('Idris.Idris2.Prelude.Types':'un--elem'({'Prelude.Interfaces.MkFoldable', fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldr_Foldable_List'(V3, V4, V5)) end end end end end, fun (V6) -> fun (V7) -> fun (V8) -> fun (V9) -> fun (V10) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldl_Foldable_List'(V8, V9, V10)) end end end end end, fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--null_Foldable_List'(V12)) end end, fun (V13) -> fun (V14) -> fun (V15) -> fun (V16) -> fun (V17) -> fun (V18) -> fun (V19) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldlM_Foldable_List'(V16, V17, V18, V19)) end end end end end end end, fun (V20) -> fun (V21) -> V21 end end, fun (V22) -> fun (V23) -> fun (V24) -> fun (V25) -> fun (V26) -> ('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'(V24, V25, V26)) end end end end end}, {'Prelude.EqOrd.MkEq', fun (V27) -> fun (V28) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V27, V28)) end end, fun (V29) -> fun (V30) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V29, V30)) end end}, case V0 of {'Libraries.Text.Bounded.MkBounded', V31, V32, V33} -> V31 end, ('un--reservedNames'()))) of 1 -> 0; 0 -> 1 end, fun () -> {'Libraries.Text.Parser.Core.Fail', {'Prelude.Types.Just', case V0 of {'Libraries.Text.Bounded.MkBounded', V34, V35, V36} -> V36 end}, 0, <<"Expected reserved identifier"/utf8>>} end)), {'Libraries.Text.Parser.Core.Empty', V0}} end end}.
'un--anyKeyword'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected a keyword"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.Keyword', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--actH'(V0) -> {'Libraries.Text.Parser.Core.Act', {'Parser.Rule.Source.MkState', {'Prelude.Basics.Lin'}, [V0 | []]}}.
'un--actD'(V0) -> {'Libraries.Text.Parser.Core.Act', {'Parser.Rule.Source.MkState', {'Prelude.Basics.:<', {'Prelude.Basics.Lin'}, V0}, []}}.
'un--aDotIdent'() -> {'Libraries.Text.Parser.Core.Terminal', <<"Expected dot+identifier"/utf8>>, fun (V0) -> case V0 of {'Parser.Lexer.Source.DotIdent', V1} -> {'Prelude.Types.Just', V1}; _ -> {'Prelude.Types.Nothing'} end end}.
'un--State'() -> {'Parser.Rule.Source.ParserState', fun (V0) -> {'Prelude.Basics.List', V0} end}.
'un--Rule'(V0) -> ('un--BRule'(1, V0)).
'un--ParsingState'() -> {'Parser.Rule.Source.ParserState', fun (V0) -> {'Prelude.Basics.SnocList', V0} end}.
'un--IndentInfo'() -> {'.Int'}.
'un--EmptyRule'(V0) -> ('un--BRule'(0, V0)).
'un--BRule'(V0, V1) -> {'Libraries.Text.Parser.Core.Grammar', ('un--ParsingState'()), {'Parser.Lexer.Source.Token'}, V0, V1}.
