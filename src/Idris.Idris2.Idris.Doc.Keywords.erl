-module('Idris.Idris2.Idris.Doc.Keywords').
-compile('no_auto_import').
-compile('inline').
-compile({'inline_size',24}).
-export([
  'un--withabstraction'/0,
  'un--whereblock'/0,
  'un--visibility'/0,
  'un--unusedSymbol'/0,
  'un--unusedKeyword'/0,
  'un--tupleSyntax'/0,
  'un--totality'/0,
  'un--symbolsDoc'/0,
  'un--rewriteeq'/0,
  'un--recordtypes'/0,
  'un--recordUpdate'/0,
  'un--rangeSyntax'/0,
  'un--parametersblock'/0,
  'un--namespaceblock'/0,
  'un--mutualblock'/0,
  'un--letbinding'/0,
  'un--lambdaAbstraction'/0,
  'un--keywordsDoc'/0,
  'un--interfacemechanism'/0,
  'un--impossibility'/0,
  'un--importing'/0,
  'un--implicitarg'/0,
  'un--ifthenelse'/0,
  'un--getDocsForSymbol'/1,
  'un--getDocsForKeyword'/1,
  'un--forallquantifier'/0,
  'un--fixity'/0,
  'un--fatArrow'/0,
  'un--failblock'/0,
  'un--doc'/1,
  'un--doblock'/0,
  'un--datatypes'/0,
  'un--caseof'/0,
  'un--bang'/0,
  'un--asPattern'/0
]).
'un--withabstraction'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"With abstraction"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V59 = fun (V55) -> fun (V56) -> fun (V57) -> fun (V58) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V57, V58)) end end end end), fun (V60) -> fun (V61) -> ((((V59('erased'))('erased'))(V60))(V61)) end end end(fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V54)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"We often need to match on the result of an intermediate computation.\x{a}When this intermediate computation additionally appears in the type of the\x{a}function being defined, the `with` construct allows us to capture these\x{a}occurences so that the observations made in the patterns will be reflected\x{a}in the type.\x{a}If we additionally need to remember that the link between the patterns and\x{a}the intermediate computation we can use the `proof` keyword to retain an\x{a}equality proof."/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"In the following example we want to implement a `filter` function that not\x{a}only returns values that satisfy the input predicate but also proofs that\x{a}they do. The `with (p x)` construct introduces a value of type `Bool`\x{a}obtained by testing `x` with `p`. The additional `proof eq` part records in\x{a}`eq` an equality proof stating that the `True`/`False` patterns in the further\x{a}clauses are equal to the result of evaluating `p x`. This is the reason why\x{a}we can successfully form `(x ** eq)` in the `True` branch.\x{a}```idris\x{a}filter : (p : a -> Bool) -> List a -> List (x : a ** p x === True)\x{a}filter p [] = []\x{a}filter p (x :: xs) with (p x) proof eq\x{a}  _ | True = (x ** eq) :: filter p xs\x{a}  _ | False = filter p xs\x{a}```"/utf8>> | []])))) | []]]]))]])).
'un--whereblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Where block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V89 = fun (V85) -> fun (V86) -> fun (V87) -> fun (V88) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V87, V88)) end end end end), fun (V90) -> fun (V91) -> ((((V89('erased'))('erased'))(V90))(V91)) end end end(fun (V84) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V84)) end))([('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--<++>'(('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<"NB:"/utf8>>)))), ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"`where` is used as a layout keyword in `data`, `record`, `interface`,\x{a}and `implementation` blocks. This documentation snippet focuses instead\x{a}on the `where` blocks introducing local definitions."/utf8>> | []])))))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<""/utf8>>)) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V81) -> fun (V82) -> <<V81/binary, V82/binary>> end end, <<""/utf8>>}, fun (V83) -> V83 end, [<<"A `where` block allows the introduction of local auxiliary definitions\x{a}that are parametrised over the variables bound on the left hand side of\x{a}the parent clause (cf. the doc for `parameters`)."/utf8>> | []])))) | []]]]))]])).
'un--visibility'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Visibility"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V77 = fun (V73) -> fun (V74) -> fun (V75) -> fun (V76) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V75, V76)) end end end end), fun (V78) -> fun (V79) -> ((((V77('erased'))('erased'))(V78))(V79)) end end end(fun (V72) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V72)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Programmers can decide which parts of a module they expose to the outside\x{a}world."/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"* `public export` ensures that both the declaration and the definition\x{a}   are accessible from the outside of the module. This means the function\x{a}   will be able to reduce in types."/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"* `export` means that only the declaration will be made available to the\x{a}  outside world. Users will be able to call the function but its internals\x{a}  will not be exposed because it will not reduce in types."/utf8>> | []])))) | [(begin (V64 = fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V63)) end), fun (V65) -> (V64(V65)) end end(<<""/utf8>>)) | [(begin (V70 = fun (V69) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V69)) end), fun (V71) -> (V70(V71)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V66) -> fun (V67) -> <<V66/binary, V67/binary>> end end, <<""/utf8>>}, fun (V68) -> V68 end, [<<"* `private` means that neither the declaration nor the definition will be\x{a}  exported. This is the default and is the ideal setting for auxiliary\x{a}  definitions."/utf8>> | []])))) | []]]]]]]]))]])).
'un--unusedSymbol'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Currently unused symbol"/utf8>>)).
'un--unusedKeyword'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Currently unused keyword"/utf8>>)).
'un--tupleSyntax'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Used to build dependent pairs together with parentheses"/utf8>>)).
'un--totality'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<"Totality"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V116 = fun (V112) -> fun (V113) -> fun (V114) -> fun (V115) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V114, V115)) end end end end), fun (V117) -> fun (V118) -> ((((V116('erased'))('erased'))(V117))(V118)) end end end(fun (V111) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V111)) end))([(begin (V82 = fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V81)) end), fun (V83) -> (V82(V83)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"Definitions can be individually declared `total`, `covering`, or `partial`.\x{a}It is also possible to set the default totality flag for definitions in a\x{a}module by using the `%default` pragma."/utf8>> | []])))) | [(begin (V85 = fun (V84) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V84)) end), fun (V86) -> (V85(V86)) end end(<<""/utf8>>)) | [(begin (V91 = fun (V90) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V90)) end), fun (V92) -> (V91(V92)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V87) -> fun (V88) -> <<V87/binary, V88/binary>> end end, <<""/utf8>>}, fun (V89) -> V89 end, [<<"* `total` offers the highest guarantees. Definitions using this flag are\x{a}  only accepted if:\x{a}    1. their patterns are covering all possible cases;\x{a}    2. they are either obviously terminating (for recursive functions)\x{a}       or productive (for corecursive functions);\x{a}    3. all the auxiliary functions used are total themselves."/utf8>> | []])))) | [(begin (V94 = fun (V93) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V93)) end), fun (V95) -> (V94(V95)) end end(<<""/utf8>>)) | [(begin (V100 = fun (V99) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V99)) end), fun (V101) -> (V100(V101)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V96) -> fun (V97) -> <<V96/binary, V97/binary>> end end, <<""/utf8>>}, fun (V98) -> V98 end, [<<"* `covering` is the default level of guarantees. It only enforces that\x{a}  pattern matchings are exhaustive."/utf8>> | []])))) | [(begin (V103 = fun (V102) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V102)) end), fun (V104) -> (V103(V104)) end end(<<""/utf8>>)) | [(begin (V109 = fun (V108) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V108)) end), fun (V110) -> (V109(V110)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V105) -> fun (V106) -> <<V105/binary, V106/binary>> end end, <<""/utf8>>}, fun (V107) -> V107 end, [<<"* `partial` is the absence of any totality requirement: as long as the\x{a}  definition typechecks, it is accepted. It is possible to call a partial\x{a}  function from a total one by using the `assert_total` escape hatch."/utf8>> | []])))) | []]]]]]]]))]])).
'un--symbolsDoc'() -> {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<""/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"An implicit value either solved by unification or bound\x{a}as a pattern or type variable."/utf8>> | []])))), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V82) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V82)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V83) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V83)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V84) -> fun (V85) -> case case (V84 =:= V85) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V81)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V86} -> case V86 of {'Builtin.MkPair', V87, V88} -> [V87 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V88))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V81)); 0 -> V81 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V89} -> case V89 of {'Builtin.MkPair', V90, V91} -> [V90 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V91))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V92) -> fun (V93) -> case case (V92 =:= V93) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V81)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V94} -> case V94 of {'Builtin.MkPair', V95, V96} -> [V95 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V96))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V81)); 0 -> V81 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V97} -> case V97 of {'Builtin.MkPair', V98, V99} -> [V98 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V99))] end end)))))))) end, fun (V100) -> fun (V101) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V102) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V102)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V103) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V103)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V104) -> fun (V105) -> case case (V104 =:= V105) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V101)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V106} -> case V106 of {'Builtin.MkPair', V107, V108} -> [V107 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V108))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V101)); 0 -> V101 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V109} -> case V109 of {'Builtin.MkPair', V110, V111} -> [V110 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V111))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V112) -> fun (V113) -> case case (V112 =:= V113) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V101)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V114} -> case V114 of {'Builtin.MkPair', V115, V116} -> [V115 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V116))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V101)); 0 -> V101 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V117} -> case V117 of {'Builtin.MkPair', V118, V119} -> [V118 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V119))] end end)))))))) end end}, <<""/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Start of a pragma"/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--lambdaAbstraction'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V120) -> fun (V121) -> <<V120/binary, V121/binary>> end end, <<""/utf8>>}, fun (V122) -> V122 end, [<<"Type declaration, for instance `id : a -> a`\x{a}declares a new toplevel definition `id` of type `a -> a`."/utf8>> | []])))), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Definition or equality type"/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Let binding or record assignment"/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--recordUpdate'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Additional patterns showing up in a `with` clause"/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Document string attached to the following definition"/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Bind in a do block"/utf8>>)), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Function type"/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--fatArrow'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"An implicit value solved by unification."/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--bang'()), {'Data.List.Quantifiers.All.::', ('un--unusedSymbol'()), {'Data.List.Quantifiers.All.::', ('un--tupleSyntax'()), {'Data.List.Quantifiers.All.::', ('un--rangeSyntax'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V123) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V124) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V124)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V125) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V125)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V126) -> fun (V127) -> case case (V126 =:= V127) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V123)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V128} -> case V128 of {'Builtin.MkPair', V129, V130} -> [V129 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V130))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V123)); 0 -> V123 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V131} -> case V131 of {'Builtin.MkPair', V132, V133} -> [V132 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V133))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V134) -> fun (V135) -> case case (V134 =:= V135) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V123)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V136} -> case V136 of {'Builtin.MkPair', V137, V138} -> [V137 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V138))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V123)); 0 -> V123 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V139} -> case V139 of {'Builtin.MkPair', V140, V141} -> [V140 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V141))] end end)))))))) end, fun (V142) -> fun (V143) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V144) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V144)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V145) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V145)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V146) -> fun (V147) -> case case (V146 =:= V147) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V143)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V148} -> case V148 of {'Builtin.MkPair', V149, V150} -> [V149 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V150))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V143)); 0 -> V143 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V151} -> case V151 of {'Builtin.MkPair', V152, V153} -> [V152 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V153))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V154) -> fun (V155) -> case case (V154 =:= V155) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V143)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V156} -> case V156 of {'Builtin.MkPair', V157, V158} -> [V157 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V158))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V143)); 0 -> V143 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V159} -> case V159 of {'Builtin.MkPair', V160, V161} -> [V160 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V161))] end end)))))))) end end}, <<""/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--asPattern'()), {'Data.List.Quantifiers.All.Nil'}}}}}}}}}}}}}}}}}}}}}}}.
'un--rewriteeq'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<"Rewrite"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V89 = fun (V85) -> fun (V86) -> fun (V87) -> fun (V88) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V87, V88)) end end end end), fun (V90) -> fun (V91) -> ((((V89('erased'))('erased'))(V90))(V91)) end end end(fun (V84) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V84)) end))([(begin (V82 = fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V81)) end), fun (V83) -> (V82(V83)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"Users can deploy an equality proof to adjust a type by replacing the value\x{a}on the left hand side of the equality by that on the right hand side.\x{a}For instance, if we know that the types `a` and `b` are propositionally\x{a}equal, we can return a value of type `a` as if it had type `b`:\x{a}```idris\x{a}transport : a === b -> a -> b\x{a}transport eq x = rewrite sym eq in x\x{a}```"/utf8>> | []])))) | []]))]])).
'un--recordtypes'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Record types"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V68 = fun (V64) -> fun (V65) -> fun (V66) -> fun (V67) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V66, V67)) end end end end), fun (V69) -> fun (V70) -> ((((V68('erased'))('erased'))(V69))(V70)) end end end(fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V63)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Records are data types with a single constructor. Each of the constructor\x{27}s\x{a}argument is given a name and the corresponding projections and record update\x{a}functions are automatically generated.\x{a}For instance, we can define a type of pairs of natural numbers"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}record Nat2 where\x{a}  constructor MkNat2\x{a}  fst : Nat\x{a}  snd : Nat\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"and we can then immediately use all of `fst`, `snd`, `{ fst := ?h1 }`,\x{a}or `{ snd $= ?h2 }` to respectively project values out of a record,\x{a}replace values, or update them."/utf8>> | []])))) | []]]]]]))]])).
'un--recordUpdate'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Record updates"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V50 = fun (V46) -> fun (V47) -> fun (V48) -> fun (V49) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V48, V49)) end end end end), fun (V51) -> fun (V52) -> ((((V50('erased'))('erased'))(V51))(V52)) end end end(fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V45)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"If a record `r` has a field `n` of type `Nat`, it is possible to either\x{a}\x{a}1. overwrite the current value with `0` by using the assignment symbol `:=`\x{a}   like so: `{ n := 0 } r`\x{a}\x{a}2. modify the current value by adding `2` by using the modification symbol `$=`\x{a}   like so: `{ n $= (2 +) } r`.\x{a}\x{a}Multiple updates can be combined in a single update by grouping a comma-separated\x{a}list of assignments and/or modifications like so: `{ a := Z, b $= S } r`."/utf8>> | []])))) | []]))]])).
'un--rangeSyntax'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> <<V0/binary, V1/binary>> end end, <<""/utf8>>}, fun (V2) -> V2 end, [<<"The ellipsis `..` can be used to generate lists or streams of values for\x{a}types that implement the `Range` interface.\x{a}\x{a}Lists can be generated using an initial value, an (optional) second value\x{a}and a final one. For instance, we can generate lists of integers like so:\x{a}  1. `[1..5]`   evaluates to `[1,2,3,4,5]`\x{a}  2. `[1,3..5]` evaluates to `[1, 3, 5]`\x{a}\x{a}Streams can be generated using an initial value and an optional second value.\x{a}For instance the following streams of integers:\x{a}  1. `[1..]`   for all positive integers\x{a}  2. `[1,3..]` for all positive odds"/utf8>> | []])))).
'un--parametersblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Parameters block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V68 = fun (V64) -> fun (V65) -> fun (V66) -> fun (V67) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V66, V67)) end end end end), fun (V69) -> fun (V70) -> ((((V68('erased'))('erased'))(V69))(V70)) end end end(fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V63)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Definitions that share a common parameter can be grouped in a parameters\x{a}block to avoid having to explicitly pass it around. Outside of the block\x{a}all the definitions will take additional arguments corresponding to the\x{a}parameters. For instance the functions in the following block all use a\x{a}default value `dflt`"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}parameters (dflt : a)\x{a}\x{a}  head : List a -> a\x{a}  head (x :: xs) = x\x{a}  head _ = dflt\x{a}\x{a}  last : List a -> a\x{a}  last [x] = x\x{a}  last (_ :: xs) = last xs\x{a}  last _ = dflt\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"and their respective types outside of the parameters block are\x{a}`head : a -> List a -> a` and `last : a -> List a -> a`."/utf8>> | []])))) | []]]]]]))]])).
'un--namespaceblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Namespace block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V50 = fun (V46) -> fun (V47) -> fun (V48) -> fun (V49) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V48, V49)) end end end end), fun (V51) -> fun (V52) -> ((((V50('erased'))('erased'))(V51))(V52)) end end end(fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V45)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Attempting to declare two functions with the same name in a given module\x{a}will lead to a scope error. Putting each one in a different `namespace`\x{a}block can help bypass this issue by ensuring that they are assigned distinct\x{a}fully qualified names. For instance\x{a}```idris\x{a}module M\x{a}\x{a}namespace Zero\x{a}  val : Nat\x{a}  val = 0\x{a}\x{a}namespace One\x{a}  val : Nat\x{a}  val = 1\x{a}```\x{a}declares a module `M` containing two values `M.Zero.val` and `M.One.val`.\x{a}You can use `export` or `public export` to control whether a function\x{a}declared in a namespace is available outside of it."/utf8>> | []])))) | []]))]])).
'un--mutualblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Mutual block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V59 = fun (V55) -> fun (V56) -> fun (V57) -> fun (V58) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V57, V58)) end end end end), fun (V60) -> fun (V61) -> ((((V59('erased'))('erased'))(V60))(V61)) end end end(fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V54)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Mutual blocks allow users to have inter-dependent declarations. For instance\x{a}we can define the `odd` and `even` checks in terms of each other like so:\x{a}```idris\x{a}mutual\x{a}\x{a}  odd : Nat -> Bool\x{a}  odd Z = False\x{a}  odd (S n) = even n\x{a}\x{a}  even : Nat -> Bool\x{a}  even Z = True\x{a}  even (S n) = odd n\x{a}```"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"Internally this is implemented in terms of the more fundamental\x{a}forward-declaration feature: all the mutual declarations come first and then\x{a}their definitions. In other words, the earlier example using a `mutual` block\x{a}is equivalent to the following\x{a}```idris\x{a}odd : Nat -> Bool\x{a}even : Nat -> Bool\x{a}\x{a}odd Z = False\x{a}odd (S n) = even n\x{a}\x{a}even Z = True\x{a}even (S n) = odd n\x{a}```"/utf8>> | []])))) | []]]]))]])).
'un--letbinding'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Let binding"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V50 = fun (V46) -> fun (V47) -> fun (V48) -> fun (V49) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V48, V49)) end end end end), fun (V51) -> fun (V52) -> ((((V50('erased'))('erased'))(V51))(V52)) end end end(fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V45)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"The `let` keyword is used for both local definitions and let bindings.\x{a}Local definitions are just like top-level definitions except that they are\x{a}defined in whatever extended context is available at the definition site.\x{a}\x{a}Let bindings can be used to bind the result of intermediate computations.\x{a}They do not necessitate but can have a type annotation. They will not unfold\x{a}in the type of subsequent terms so may not be appropriate in all cases.\x{a}\x{a}For instance, in the following definition the let-bound value `square`\x{a}ensures that `n * n` is only computed once:\x{a}```idris\x{a}power4 : Nat -> Nat\x{a}power4 n = let square := n * n in square * square\x{a}```\x{a}\x{a}It is also possible to pattern-match on the result of the intermediate\x{a}computation. The main pattern is written in place of the variable and\x{a}an alternative list of clauses can be given using the `|` separator.\x{a}For instance, we can shortcut the `square * square` computation in case\x{a}the returned value is 0 like so:\x{a}```idris\x{a}power4 : Nat -> Nat\x{a}power4 n = let square@(S _) := n * n\x{a}                 | Z => Z\x{a}           in square * square\x{a}```"/utf8>> | []])))) | []]))]])).
'un--lambdaAbstraction'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> <<V0/binary, V1/binary>> end end, <<""/utf8>>}, fun (V2) -> V2 end, [<<"An anonymous function is introduced using a lambda `\x{5c}` and binds a\x{a}comma-separated list of either variable names or irrefutable patterns\x{a}before returning a right hand side using `=>`.\x{a}\x{a}For instance we can implement `transport` like so:\x{a}```\x{a}transport : a === b -> a -> b\x{a}transport = \x{5c} Refl, v => v\x{a}```"/utf8>> | []])))).
'un--keywordsDoc'() -> {'Data.List.Quantifiers.All.::', ('un--datatypes'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Keyword to start a module definition"/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--whereblock'()), {'Data.List.Quantifiers.All.::', ('un--letbinding'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Used by `let` and `rewrite`. See either of them for more details."/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--doblock'()), {'Data.List.Quantifiers.All.::', ('un--recordtypes'()), {'Data.List.Quantifiers.All.::', ('un--implicitarg'()), {'Data.List.Quantifiers.All.::', ('un--implicitarg'()), {'Data.List.Quantifiers.All.::', ('un--unusedKeyword'()), {'Data.List.Quantifiers.All.::', ('un--failblock'()), {'Data.List.Quantifiers.All.::', ('un--mutualblock'()), {'Data.List.Quantifiers.All.::', ('un--namespaceblock'()), {'Data.List.Quantifiers.All.::', ('un--parametersblock'()), {'Data.List.Quantifiers.All.::', ('un--withabstraction'()), {'Data.List.Quantifiers.All.::', ('un--withabstraction'()), {'Data.List.Quantifiers.All.::', ('un--impossibility'()), {'Data.List.Quantifiers.All.::', ('un--caseof'()), {'Data.List.Quantifiers.All.::', ('un--caseof'()), {'Data.List.Quantifiers.All.::', ('un--ifthenelse'()), {'Data.List.Quantifiers.All.::', ('un--ifthenelse'()), {'Data.List.Quantifiers.All.::', ('un--ifthenelse'()), {'Data.List.Quantifiers.All.::', ('un--forallquantifier'()), {'Data.List.Quantifiers.All.::', ('un--rewriteeq'()), {'Data.List.Quantifiers.All.::', ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)), {'Data.List.Quantifiers.All.::', ('un--interfacemechanism'()), {'Data.List.Quantifiers.All.::', ('un--interfacemechanism'()), {'Data.List.Quantifiers.All.::', ('un--unusedKeyword'()), {'Data.List.Quantifiers.All.::', ('un--importing'()), {'Data.List.Quantifiers.All.::', ('un--visibility'()), {'Data.List.Quantifiers.All.::', ('un--visibility'()), {'Data.List.Quantifiers.All.::', ('un--visibility'()), {'Data.List.Quantifiers.All.::', ('un--fixity'()), {'Data.List.Quantifiers.All.::', ('un--fixity'()), {'Data.List.Quantifiers.All.::', ('un--fixity'()), {'Data.List.Quantifiers.All.::', ('un--fixity'()), {'Data.List.Quantifiers.All.::', ('un--totality'()), {'Data.List.Quantifiers.All.::', ('un--totality'()), {'Data.List.Quantifiers.All.::', ('un--totality'()), {'Data.List.Quantifiers.All.Nil'}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}.
'un--interfacemechanism'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Interfaces"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V77 = fun (V73) -> fun (V74) -> fun (V75) -> fun (V76) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V75, V76)) end end end end), fun (V78) -> fun (V79) -> ((((V77('erased'))('erased'))(V78))(V79)) end end end(fun (V72) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V72)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Interfaces offer ad-hoc polymorphism. Programmers can declare new\x{a}interfaces offering a set of methods (some of which may have default\x{a}implementations in terms of the interface\x{27}s other methods) and write\x{a}programs generic over all types implementing the interface."/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"In the following example we define a `Fail` interface that allows\x{a}users to abort in case a computation is doomed to fail. We implement\x{a}the `whenJust` construct using this interface and show a couple of\x{a}implementations:"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"```idris\x{a}interface Fail (0 a : Type) where\x{a}  fail : a\x{a}\x{a}whenJust : Fail ret => Maybe a -> (a -> ret) -> ret\x{a}whenJust (Just v) k = k v\x{a}whenJust Nothing  _ = fail\x{a}\x{a}implementation Fail Bool where\x{a}  fail = False\x{a}\x{a}Fail (Maybe a) where\x{a}  fail = Nothing\x{a}```"/utf8>> | []])))) | [(begin (V64 = fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V63)) end), fun (V65) -> (V64(V65)) end end(<<""/utf8>>)) | [(begin (V70 = fun (V69) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V69)) end), fun (V71) -> (V70(V71)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V66) -> fun (V67) -> <<V66/binary, V67/binary>> end end, <<""/utf8>>}, fun (V68) -> V68 end, [<<"As you can see the `implementation` keyword is optional. Note that the\x{a}proof search machinery powering interface resolution works best if your\x{a}implementations are for specific type constructors (here `Bool` and `Maybe`)."/utf8>> | []])))) | []]]]]]]]))]])).
'un--impossibility'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Impossible branches"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V59 = fun (V55) -> fun (V56) -> fun (V57) -> fun (V58) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V57, V58)) end end end end), fun (V60) -> fun (V61) -> ((((V59('erased'))('erased'))(V60))(V61)) end end end(fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V54)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"The `impossible` keyword can be used to dismiss a clause involving an\x{a}argument with an uninhabited type. For instance an assumption stating\x{a}that 0 is equal to 1:"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}zeroIsNotOne : 0 === 1 -> Void\x{a}zeroIsNotOne eq impossible\x{a}```"/utf8>> | []])))) | []]]]))]])).
'un--importing'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<"Importing"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V89 = fun (V85) -> fun (V86) -> fun (V87) -> fun (V88) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V87, V88)) end end end end), fun (V90) -> fun (V91) -> ((((V89('erased'))('erased'))(V90))(V91)) end end end(fun (V84) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V84)) end))([(begin (V82 = fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V81)) end), fun (V83) -> (V82(V83)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"Importing a module brings the definition it exports into scope.\x{a}Combined with `public` it also re-exports these definitions."/utf8>> | []])))) | []]))]])).
'un--implicitarg'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Implicit arguments"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V68 = fun (V64) -> fun (V65) -> fun (V66) -> fun (V67) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V66, V67)) end end end end), fun (V69) -> fun (V70) -> ((((V68('erased'))('erased'))(V69))(V70)) end end end(fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V63)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Implicit arguments can be solved using various strategies. By default\x{a}they will be filled in using unification but programmers can use various\x{a}keywords to change that."/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"* `auto` will use the same mechanism as interface resolution to build the\x{a}  argument. Users can add new hints to the database by adding a `%hint`\x{a}  pragma to their declarations. By default all data constructors are hints.\x{a}  For instance, the following function\x{a}  ```idris\x{a}  f : (n : Nat) -> {auto _ : n === Z} -> Nat\x{a}  f n = n\x{a}  ```\x{a}  will only accept arguments that can be automatically proven to be equal\x{a}  to zero."/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"* `default` takes a value of the appropriate type and if no argument is\x{a}  explicitly passed at a call site, will use that default value.\x{a}  For instance, the following function\x{a}  ```idris\x{a}  f : {default 0 n : Nat} -> Nat\x{a}  f = n\x{a}  ```\x{a}  will return `0` if no argument is passed and its argument otherwise."/utf8>> | []])))) | []]]]]]))]])).
'un--ifthenelse'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Boolean conditional"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V80 = fun (V76) -> fun (V77) -> fun (V78) -> fun (V79) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V78, V79)) end end end end), fun (V81) -> fun (V82) -> ((((V80('erased'))('erased'))(V81))(V82)) end end end(fun (V75) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V75)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"The `if ... then ... else ...` construct is dependently typed. This means\x{a}that if you are branching over a variable, the branches will have refined\x{a}types where that variable has been replaced by either `True` or `False`.\x{a}For instance, in the following incomplete program"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}notInvolutive : (b : Bool) -> not (not b) === b\x{a}notInvolutive b = if b then ?holeTrue else ?holeFalse\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"the two holes have respective types `True === True` and `False === False`."/utf8>> | []])))) | [(begin (V64 = fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V63)) end), fun (V65) -> (V64(V65)) end end(<<""/utf8>>)) | [(begin (V67 = fun (V66) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V66)) end), fun (V68) -> (V67(V68)) end end(<<""/utf8>>)) | [(begin (V73 = fun (V72) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V72)) end), fun (V74) -> (V73(V74)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V69) -> fun (V70) -> <<V69/binary, V70/binary>> end end, <<""/utf8>>}, fun (V71) -> V71 end, [<<"If you do not need the added power granted by dependently typed branches,\x{a}consider using the simpler `ifThenElse` function defined in `Prelude`."/utf8>> | []])))) | []]]]]]]]]))]])).
'un--getDocsForSymbol'(V0) -> ('Idris.Idris2.Prelude.Types':'un--maybe'(fun () -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--annotate'({'Idris.Doc.Annotations.Syntax', {'Idris.Pretty.Annotations.Keyword'}}, ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--pretty_Pretty_Void_String'(V1)) end, fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--prettyPrec_Pretty_Void_String'(V2, V3)) end end}, V0)))) end, fun () -> fun (V4) -> ('un--doc'(V4)) end end, ('Idris.Idris2.Libraries.Data.List.Quantifiers.Extra':'un--lookup'(('Idris.Idris2.Prelude.Types.List':'un--tailRecAppend'(('Idris.Idris2.Parser.Lexer.Source':'un--symbols'()), ('Idris.Idris2.Parser.Lexer.Source':'un--reservedInfixSymbols'()))), fun (V5) -> fun (V6) -> ((('Idris.Idris2.Decidable.Equality':'dn--un--decEq_DecEq_String'())(V5))(V6)) end end, V0, ('un--symbolsDoc'()))))).
'un--getDocsForKeyword'(V0) -> ('Idris.Idris2.Prelude.Types':'un--maybe'(fun () -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--annotate'({'Idris.Doc.Annotations.Syntax', {'Idris.Pretty.Annotations.Keyword'}}, ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--pretty_Pretty_Void_String'(V1)) end, fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--prettyPrec_Pretty_Void_String'(V2, V3)) end end}, V0)))) end, fun () -> fun (V4) -> ('un--doc'(V4)) end end, ('Idris.Idris2.Libraries.Data.List.Quantifiers.Extra':'un--lookup'(('Idris.Idris2.Parser.Lexer.Source':'un--keywords'()), fun (V5) -> fun (V6) -> ((('Idris.Idris2.Decidable.Equality':'dn--un--decEq_DecEq_String'())(V5))(V6)) end end, V0, ('un--keywordsDoc'()))))).
'un--forallquantifier'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Forall quantifier"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V50 = fun (V46) -> fun (V47) -> fun (V48) -> fun (V49) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V48, V49)) end end end end), fun (V51) -> fun (V52) -> ((((V50('erased'))('erased'))(V51))(V52)) end end end(fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V45)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"`forall` quantification is syntactic sugar for implicit runtime-irrelevant\x{a}universal quantification. That is to say that `forall x, y, z. ...`\x{a}desugars to `{0 x, y, z : _} -> ...`."/utf8>> | []])))) | []]))]])).
'un--fixity'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Fixity declarations"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V50 = fun (V46) -> fun (V47) -> fun (V48) -> fun (V49) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V48, V49)) end end end end), fun (V51) -> fun (V52) -> ((((V50('erased'))('erased'))(V51))(V52)) end end end(fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V45)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Operators can be assigned a priority level and associativity. During parsing\x{a}operators with a higher priority will collect their arguments first and the\x{a}declared associativity will inform how subterms are grouped.\x{a}\x{a}For instance the expression `a + b * c * d + e` is parsed as\x{a}`(a + ((b * c) * d)) + e` because:\x{a}  `(+)` is at level 8 and associates to the left\x{a}  `(*)` is at level 9 and associates to the left"/utf8>> | []])))) | []]))]])).
'un--fatArrow'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> <<V0/binary, V1/binary>> end end, <<""/utf8>>}, fun (V2) -> V2 end, [<<"Used for an interface constraint in a type signature or as part of a\x{a}lambda abstraction or case block.\x{a}\x{a}1. Interface constraint"/utf8>> | []])))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, (begin (V7 = fun (V6) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V6)) end), fun (V8) -> (V7(V8)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V3) -> fun (V4) -> <<V3/binary, V4/binary>> end end, <<""/utf8>>}, fun (V5) -> V5 end, [<<"`a => b` corresponds to `{auto _ : a} -> b`"/utf8>> | []])))))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V9) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V10) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V10)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V11) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V11)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V12) -> fun (V13) -> case case (V12 =:= V13) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V9)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V14} -> case V14 of {'Builtin.MkPair', V15, V16} -> [V15 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V16))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V9)); 0 -> V9 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V17} -> case V17 of {'Builtin.MkPair', V18, V19} -> [V18 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V19))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V20) -> fun (V21) -> case case (V20 =:= V21) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V9)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V22} -> case V22 of {'Builtin.MkPair', V23, V24} -> [V23 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V24))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V9)); 0 -> V9 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))))))) end, fun (V28) -> fun (V29) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V30) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V30)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V31) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V31)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V32) -> fun (V33) -> case case (V32 =:= V33) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V29)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V34} -> case V34 of {'Builtin.MkPair', V35, V36} -> [V35 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V36))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V29)); 0 -> V29 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V37} -> case V37 of {'Builtin.MkPair', V38, V39} -> [V38 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V39))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V40) -> fun (V41) -> case case (V40 =:= V41) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V29)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V42} -> case V42 of {'Builtin.MkPair', V43, V44} -> [V43 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V44))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V29)); 0 -> V29 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V45} -> case V45 of {'Builtin.MkPair', V46, V47} -> [V46 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V47))] end end)))))))) end end}, <<""/utf8>>)) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"2. Lambda abstraction"/utf8>> | []])))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, ('un--lambdaAbstraction'()))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V52) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V52)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V53) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V53)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V54) -> fun (V55) -> case case (V54 =:= V55) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V51)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V56} -> case V56 of {'Builtin.MkPair', V57, V58} -> [V57 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V58))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V51)); 0 -> V51 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V59} -> case V59 of {'Builtin.MkPair', V60, V61} -> [V60 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V61))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V51)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V51)); 0 -> V51 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end)))))))) end, fun (V70) -> fun (V71) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V72) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V72)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V73) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V73)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V74) -> fun (V75) -> case case (V74 =:= V75) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V71)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V76} -> case V76 of {'Builtin.MkPair', V77, V78} -> [V77 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V78))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V71)); 0 -> V71 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V79} -> case V79 of {'Builtin.MkPair', V80, V81} -> [V80 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V81))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V82) -> fun (V83) -> case case (V82 =:= V83) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V71)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V84} -> case V84 of {'Builtin.MkPair', V85, V86} -> [V85 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V86))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V71)); 0 -> V71 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V87} -> case V87 of {'Builtin.MkPair', V88, V89} -> [V88 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V89))] end end)))))))) end end}, <<""/utf8>>)) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V90) -> fun (V91) -> <<V90/binary, V91/binary>> end end, <<""/utf8>>}, fun (V92) -> V92 end, [<<"3. Case block"/utf8>> | []])))) | []]]]]]]])).
'un--failblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Fail block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V68 = fun (V64) -> fun (V65) -> fun (V66) -> fun (V67) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V66, V67)) end end end end), fun (V69) -> fun (V70) -> ((((V68('erased'))('erased'))(V69))(V70)) end end end(fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V63)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Fail blocks let users check that some code parses but is rejected during elaboration.\x{a}In the following example, we make sure that Idris rejects a proof that the character\x{a}\x{27}a\x{27} is equal to \x{27}b\x{27} by throwing an error when unifying them."/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}failing \x{22}When unifying\x{22}\x{a}  noteq : \x{27}a\x{27} === \x{27}b\x{27}\x{a}  noteq = Refl\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"If the (optional) string attached to a failing block does not appear in the error raised,\x{a}or if no error is raised then the failing block is itself failing and thus leads to an error.\x{a}This lets users document the kind of error the block is meant to document."/utf8>> | []])))) | []]]]]]))]])).
'un--doc'(V0) -> begin (V1 = V0), V1 end.
'un--doblock'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<"Do block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V39) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V40) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V40)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V41) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V41)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V42) -> fun (V43) -> case case (V42 =:= V43) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V44} -> case V44 of {'Builtin.MkPair', V45, V46} -> [V45 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V46))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V47} -> case V47 of {'Builtin.MkPair', V48, V49} -> [V48 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V49))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V50) -> fun (V51) -> case case (V50 =:= V51) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V39)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V52} -> case V52 of {'Builtin.MkPair', V53, V54} -> [V53 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V54))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V39)); 0 -> V39 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V55} -> case V55 of {'Builtin.MkPair', V56, V57} -> [V56 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V57))] end end)))))))) end, fun (V58) -> fun (V59) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V60)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V61) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V61)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V62) -> fun (V63) -> case case (V62 =:= V63) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V64} -> case V64 of {'Builtin.MkPair', V65, V66} -> [V65 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V66))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V67} -> case V67 of {'Builtin.MkPair', V68, V69} -> [V68 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V69))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V70) -> fun (V71) -> case case (V70 =:= V71) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V59)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V72} -> case V72 of {'Builtin.MkPair', V73, V74} -> [V73 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V74))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V59)); 0 -> V59 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V75} -> case V75 of {'Builtin.MkPair', V76, V77} -> [V76 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V77))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V98 = fun (V94) -> fun (V95) -> fun (V96) -> fun (V97) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V96, V97)) end end end end), fun (V99) -> fun (V100) -> ((((V98('erased'))('erased'))(V99))(V100)) end end end(fun (V93) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V93)) end))([(begin (V82 = fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V81)) end), fun (V83) -> (V82(V83)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V78) -> fun (V79) -> <<V78/binary, V79/binary>> end end, <<""/utf8>>}, fun (V80) -> V80 end, [<<"Do blocks are a popular way to structure (among other things) effectful code.\x{a}They are desugared using `(>>=)` and `(>>)` respectively depending on whether\x{a}the result of a subcomputation is bound. Let bindings and local definitions\x{a}can be used (omitting `in` because the layout is already controlled by the\x{a}`do`-based indentation) and desugared to the corresponding `let` constructs.\x{a}\x{a}For instance the following block\x{a}```idris\x{a}  do x <- e1\x{a}     e2\x{a}     let y = e3\x{a}     e4\x{a}```\x{a}is equivalent to the expression `e1 >>= \x{5c} x => e2 >> let y = e3 in e4`."/utf8>> | []])))) | [(begin (V85 = fun (V84) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V84)) end), fun (V86) -> (V85(V86)) end end(<<""/utf8>>)) | [(begin (V91 = fun (V90) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V90)) end), fun (V92) -> (V91(V92)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V87) -> fun (V88) -> <<V87/binary, V88/binary>> end end, <<""/utf8>>}, fun (V89) -> V89 end, [<<"By default `(>>=)` and `(>>)` are then selected using the usual type\x{a}directed disambiguation mechanisms. Users who want to bypass this implicit\x{a}disambiguation step can use a qualified `do`: by writing `M.do` they ensure\x{a}Idris will explicitly use `M.(>>=)` and `M.(>>)` during elaboration."/utf8>> | []])))) | []]]]))]])).
'un--datatypes'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"(Co)Data types"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V86 = fun (V82) -> fun (V83) -> fun (V84) -> fun (V85) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V84, V85)) end end end end), fun (V87) -> fun (V88) -> ((((V86('erased'))('erased'))(V87))(V88)) end end end(fun (V81) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V81)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"Keyword to introduce a (co)inductive type definition.\x{a}You can either use a BNF-style definition for simple types"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}data List a = Nil | (::) a (List a)\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"or a GADT-style definition for indexed types"/utf8>> | []])))) | [(begin (V64 = fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V63)) end), fun (V65) -> (V64(V65)) end end(<<""/utf8>>)) | [(begin (V70 = fun (V69) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V69)) end), fun (V71) -> (V70(V71)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V66) -> fun (V67) -> <<V66/binary, V67/binary>> end end, <<""/utf8>>}, fun (V68) -> V68 end, [<<"```idris\x{a}data Vect : Nat -> Type -> Type where\x{a}  Nil  : Vect 0 a\x{a}  (::) : a -> Vect n a -> Vect (S n) a\x{a}```"/utf8>> | []])))) | [(begin (V73 = fun (V72) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V72)) end), fun (V74) -> (V73(V74)) end end(<<""/utf8>>)) | [(begin (V79 = fun (V78) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V78)) end), fun (V80) -> (V79(V80)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V75) -> fun (V76) -> <<V75/binary, V76/binary>> end end, <<""/utf8>>}, fun (V77) -> V77 end, [<<"Coinductive data is introduced using the same syntax except\x{a}that the type of potentially infinite subterms is wrapped in\x{a}an `Inf` type constructor."/utf8>> | []])))) | []]]]]]]]]]))]])).
'un--caseof'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vcat'([('Idris.Idris2.Idris.Doc.Annotations':'un--header'(('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(<<"Case block"/utf8>>)))) | [('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--pretty0'({'Libraries.Text.PrettyPrint.Prettyprinter.Doc.dn--un--__mkPretty', fun (V0) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V1) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V1)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V2) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V2)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V3) -> fun (V4) -> case case (V3 =:= V4) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V5} -> case V5 of {'Builtin.MkPair', V6, V7} -> [V6 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V7))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V8} -> case V8 of {'Builtin.MkPair', V9, V10} -> [V9 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V10))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V11) -> fun (V12) -> case case (V11 =:= V12) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V0)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V13} -> case V13 of {'Builtin.MkPair', V14, V15} -> [V14 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V15))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V0)); 0 -> V0 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V16} -> case V16 of {'Builtin.MkPair', V17, V18} -> [V17 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V18))] end end)))))))) end, fun (V19) -> fun (V20) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--vsep'(('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V21) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--unsafeTextWithoutNewLines'(V21)) end, ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, fun (V22) -> ('Idris.Idris2.Prelude.Types':'un--fastPack'(V22)) end, ('Idris.Idris2.Data.String':'nested--3893-7830--in--un--linesHelp'(case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V23) -> fun (V24) -> case case (V23 =:= V24) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V25} -> case V25 of {'Builtin.MkPair', V26, V27} -> [V26 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V27))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V28} -> case V28 of {'Builtin.MkPair', V29, V30} -> [V29 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V30))] end end, [], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(case ('Idris.Idris2.Data.List':'un--isPrefixOfBy'(fun (V31) -> fun (V32) -> case case (V31 =:= V32) of 'false' -> 0; _ -> 1 end of 0 -> 0; _ -> 1 end end end, [$\x{a} | []], ('Idris.Idris2.Prelude.Types.List':'un--reverseOnto'([], case ('Idris.Idris2.Prelude.Types':'un--strUncons'(V20)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V33} -> case V33 of {'Builtin.MkPair', V34, V35} -> [V34 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V35))] end end)))) of 1 -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--dropLast'(1, V20)); 0 -> V20 end)) of {'Prelude.Types.Nothing'} -> []; {'Prelude.Types.Just', V36} -> case V36 of {'Builtin.MkPair', V37, V38} -> [V37 | ('Idris.Idris2.Prelude.Types':'un--unpack'(V38))] end end)))))))) end end}, <<""/utf8>>)) | ((begin (V68 = fun (V64) -> fun (V65) -> fun (V66) -> fun (V67) -> ('Idris.Idris2.Prelude.Types.List':'un--mapAppend'({'Prelude.Basics.Lin'}, V66, V67)) end end end end), fun (V69) -> fun (V70) -> ((((V68('erased'))('erased'))(V69))(V70)) end end end(fun (V63) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'un--indent'(2, V63)) end))([(begin (V43 = fun (V42) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V42)) end), fun (V44) -> (V43(V44)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V39) -> fun (V40) -> <<V39/binary, V40/binary>> end end, <<""/utf8>>}, fun (V41) -> V41 end, [<<"The `case ... of ...` construct is dependently typed. This means that if you\x{a}are branching over a variable, the branches will have refined types where\x{a}that variable has been replaced by the appropriate pattern.\x{a}For instance, in the following program"/utf8>> | []])))) | [(begin (V46 = fun (V45) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V45)) end), fun (V47) -> (V46(V47)) end end(<<""/utf8>>)) | [(begin (V52 = fun (V51) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V51)) end), fun (V53) -> (V52(V53)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V48) -> fun (V49) -> <<V48/binary, V49/binary>> end end, <<""/utf8>>}, fun (V50) -> V50 end, [<<"```idris\x{a}assoc : (ma, mb, mc : Maybe a) ->\x{a}        ((ma <|> mb) <|> mc) === (ma <|> (mb <|> mc))\x{a}assoc ma mb mc = case ma of\x{a}  Nothing => Refl\x{a}  Just a  => Refl\x{a}```"/utf8>> | []])))) | [(begin (V55 = fun (V54) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V54)) end), fun (V56) -> (V55(V56)) end end(<<""/utf8>>)) | [(begin (V61 = fun (V60) -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(V60)) end), fun (V62) -> (V61(V62)) end end(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V57) -> fun (V58) -> <<V57/binary, V58/binary>> end end, <<""/utf8>>}, fun (V59) -> V59 end, [<<"the branches typecheck because in their respective types `ma` has been replaced\x{a}either by `Nothing` or `Just a` and that was enough for them to compute to\x{a}`(mb <|> mc) === (mb <|> mc)` and `Just a === Just a` respectively. Both of\x{a}which can be discharged using `Refl`."/utf8>> | []])))) | []]]]]]))]])).
'un--bang'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> <<V0/binary, V1/binary>> end end, <<""/utf8>>}, fun (V2) -> V2 end, [<<"Directive to lift the following effectful expression to the nearest enclosing\x{a}(potentially implicit) `do` block. In the following definition for instance\x{a}\x{a}```\x{a}anyM : Monad m => (a -> m Bool) -> List a -> m (Maybe a)\x{a}anyM p [] = pure Nothing\x{a}anyM p (x :: xs) = if !(p x) then pure (Just x) else anyM p xs\x{a}```\x{a}\x{a}the expression `if !(p x) then pure (Just x) else anyM p xs` is equivalent to\x{a}the following `do` block:\x{a}\x{a}```\x{a}do b <- p x\x{a}   if b then pure (Just x) else anyM p xs\x{a}```"/utf8>> | []])))).
'un--asPattern'() -> ('Idris.Idris2.Libraries.Text.PrettyPrint.Prettyprinter.Doc':'dn--un--fromString_FromString_(Doc $ann)'(('Idris.Idris2.Prelude.Types':'dn--un--foldMap_Foldable_List'({'Prelude.Interfaces.MkMonoid', fun (V0) -> fun (V1) -> <<V0/binary, V1/binary>> end end, <<""/utf8>>}, fun (V2) -> V2 end, [<<"An as pattern `@` can be used to both pattern match on a variable\x{a}and retain a name for the compound expression. E.g. instead of writing\x{a}```\x{a}last : List a -> Maybe a\x{a}last [] = Nothing\x{a}last [x] = Just x\x{a}last (x :: y :: ys) = last (y :: ys)\x{a}```\x{a}\x{a}where, in the last clasue, we take `y :: ys` apart on the left hand side\x{a}before reconstructing it on the right hand side, we can write:\x{a}\x{a}```\x{a}last (x :: xs@(_ :: _)) = last xs\x{a}```"/utf8>> | []])))).
